{"version":3,"file":"medical-service-worker-DG4fFSL8.js","sources":["../../src/workers/medical-service-worker.js"],"sourcesContent":["/**\n * Medical Service Worker for Offline-First Stroke Triage Assistant\n * iGFAP Stroke Triage Assistant - Phase 3 Advanced Features\n *\n * Provides intelligent offline capabilities for critical medical operations with bulletproof error handling\n */\n\n// Bulletproof error handling for service worker\nconst ERROR_CATEGORIES = {\n  CACHE: \"cache\",\n  NETWORK: \"network\",\n  MEDICAL: \"medical\",\n  STORAGE: \"storage\",\n};\n\nconst ERROR_SEVERITY = {\n  LOW: \"low\",\n  MEDIUM: \"medium\",\n  HIGH: \"high\",\n  CRITICAL: \"critical\",\n};\n\n/**\n * Safe async wrapper for service worker operations\n */\nasync function safeAsync(operation, fallback = null, context = {}) {\n  try {\n    return await operation();\n  } catch (error) {\n    console.error(\"Service Worker error:\", error.message, context);\n\n    // Send error to main thread\n    try {\n      const clients = await self.clients.matchAll();\n      clients.forEach(client => {\n        client.postMessage({\n          type: \"SW_ERROR\",\n          error: {\n            message: error.message,\n            context,\n            timestamp: new Date().toISOString(),\n          },\n        });\n      });\n    } catch (msgError) {\n      console.error(\"Failed to send error message to clients:\", msgError);\n    }\n\n    return typeof fallback === \"function\" ? fallback(error) : fallback;\n  }\n}\n\nconst CACHE_VERSION = \"medical-app-v3.0.0\";\nconst STATIC_CACHE_NAME = `${CACHE_VERSION}-static`;\nconst API_CACHE_NAME = `${CACHE_VERSION}-api`;\nconst RUNTIME_CACHE_NAME = `${CACHE_VERSION}-runtime`;\n\n// Critical resources that must be available offline\nconst CRITICAL_RESOURCES = [\n  \"/0925/\",\n  \"/0925/index.html\",\n  \"/0925/src/main.js\",\n  \"/0925/src/app.js\",\n  \"/0925/src/config.js\",\n  \"/0925/src/state/store.js\",\n  \"/0925/src/logic/validate.js\",\n  \"/0925/src/logic/ich-volume-calculator.js\",\n  \"/0925/src/logic/lvo-local-model.js\",\n  \"/0925/src/ui/render.js\",\n  \"/0925/src/styles/app.css\",\n  \"/0925/manifest.json\",\n  \"/0925/icon-192.png\",\n  \"/0925/icon-512.png\",\n];\n\n// API endpoints for intelligent caching\nconst API_ENDPOINTS = [\n  \"https://europe-west3-igfap-452720.cloudfunctions.net/predict_coma_ich\",\n  \"https://europe-west3-igfap-452720.cloudfunctions.net/predict_limited_data_ich\",\n  \"https://europe-west3-igfap-452720.cloudfunctions.net/predict_full_stroke\",\n];\n\n// Network strategies\nconst NETWORK_STRATEGIES = {\n  CACHE_FIRST: \"cache-first\",\n  NETWORK_FIRST: \"network-first\",\n  NETWORK_ONLY: \"network-only\",\n  CACHE_ONLY: \"cache-only\",\n  STALE_WHILE_REVALIDATE: \"stale-while-revalidate\",\n};\n\n/**\n * Service Worker Installation with bulletproof error handling\n */\nself.addEventListener(\"install\", event => {\n  // Medical Service Worker installing\n\n  event.waitUntil(\n    safeAsync(\n      async () => {\n        // Pre-cache critical resources with individual error handling\n        const staticCache = await caches.open(STATIC_CACHE_NAME);\n\n        // Cache resources individually to prevent single failure from blocking entire installation\n        const cacheResults = await Promise.allSettled(\n          CRITICAL_RESOURCES.map(async resource => {\n            try {\n              const response = await fetch(resource);\n              if (response.ok) {\n                return staticCache.put(resource, response);\n              }\n              throw new Error(`Failed to fetch ${resource}: ${response.status}`);\n            } catch (fetchError) {\n              console.warn(`Failed to cache critical resource ${resource}:`, fetchError.message);\n              return null;\n            }\n          })\n        );\n\n        const successfulCaches = cacheResults.filter(\n          result => result.status === \"fulfilled\"\n        ).length;\n        const failedCaches = CRITICAL_RESOURCES.length - successfulCaches;\n\n        if (failedCaches > CRITICAL_RESOURCES.length / 2) {\n          throw new Error(\n            `Too many critical resources failed to cache: ${failedCaches}/${CRITICAL_RESOURCES.length}`\n          );\n        }\n\n        // Initialize API and runtime caches\n        await Promise.allSettled([caches.open(API_CACHE_NAME), caches.open(RUNTIME_CACHE_NAME)]);\n\n        // Medical Service Worker installed successfully\n\n        // Send installation success message\n        try {\n          const clients = await self.clients.matchAll();\n          clients.forEach(client => {\n            client.postMessage({\n              type: \"SW_INSTALLED\",\n              cacheVersion: CACHE_VERSION,\n              criticalResourcesCount: CRITICAL_RESOURCES.length,\n              successfulCaches,\n              failedCaches,\n              timestamp: new Date().toISOString(),\n            });\n          });\n        } catch (msgError) {\n          console.warn(\"Failed to send installation message:\", msgError.message);\n        }\n\n        // Skip waiting to activate immediately\n        self.skipWaiting();\n\n        return { success: true, successfulCaches, failedCaches };\n      },\n      error => {\n        // Fallback for installation failure\n        console.error(\"Service Worker installation failed:\", error.message);\n\n        try {\n          const clients = self.clients.matchAll();\n          clients.then(clientList => {\n            clientList.forEach(client => {\n              client.postMessage({\n                type: \"SW_INSTALL_ERROR\",\n                error: error.message,\n                timestamp: new Date().toISOString(),\n              });\n            });\n          });\n        } catch (msgError) {\n          console.error(\"Failed to send installation error message:\", msgError.message);\n        }\n\n        return { success: false, error: error.message };\n      },\n      {\n        operation: \"service_worker_installation\",\n        criticalResourcesCount: CRITICAL_RESOURCES.length,\n      }\n    )\n  );\n});\n\n/**\n * Service Worker Activation with bulletproof error handling\n */\nself.addEventListener(\"activate\", event => {\n  // Medical Service Worker activating\n\n  event.waitUntil(\n    safeAsync(\n      async () => {\n        // Clean up old caches with individual error handling\n        const cacheNames = await caches.keys();\n        const oldCaches = cacheNames.filter(\n          name => name.startsWith(\"medical-app-v\") && !name.includes(CACHE_VERSION)\n        );\n\n        const cleanupResults = await Promise.allSettled(\n          oldCaches.map(async cacheName => {\n            try {\n              const deleted = await caches.delete(cacheName);\n              return { cacheName, deleted };\n            } catch (error) {\n              console.warn(`Failed to delete cache ${cacheName}:`, error.message);\n              return { cacheName, deleted: false, error: error.message };\n            }\n          })\n        );\n\n        const successfulCleanups = cleanupResults.filter(\n          result => result.status === \"fulfilled\" && result.value.deleted\n        ).length;\n\n        // Cleaned up old caches\n\n        // Claim all clients with timeout\n        await Promise.race([\n          self.clients.claim(),\n          new Promise((_, reject) =>\n            setTimeout(() => reject(new Error(\"Client claim timeout\")), 5000)\n          ),\n        ]);\n\n        // Medical Service Worker activated\n\n        // Notify clients of activation\n        const clients = await self.clients.matchAll();\n        const notificationPromises = clients.map(client => {\n          try {\n            return client.postMessage({\n              type: \"SW_ACTIVATED\",\n              cacheVersion: CACHE_VERSION,\n              cleanedCaches: successfulCleanups,\n              totalOldCaches: oldCaches.length,\n              timestamp: new Date().toISOString(),\n            });\n          } catch (error) {\n            console.warn(\"Failed to notify client of activation:\", error.message);\n            return null;\n          }\n        });\n\n        await Promise.allSettled(notificationPromises);\n\n        return { success: true, cleanedCaches: successfulCleanups };\n      },\n      error => {\n        console.error(\"Service Worker activation failed:\", error.message);\n\n        // Try to notify clients of activation failure\n        safeAsync(\n          async () => {\n            const clients = await self.clients.matchAll();\n            clients.forEach(client => {\n              client.postMessage({\n                type: \"SW_ACTIVATION_ERROR\",\n                error: error.message,\n                timestamp: new Date().toISOString(),\n              });\n            });\n          },\n          null,\n          { operation: \"activation_error_notification\" }\n        );\n\n        return { success: false, error: error.message };\n      },\n      {\n        operation: \"service_worker_activation\",\n      }\n    )\n  );\n});\n\n/**\n * Fetch Event Handler with Intelligent Caching\n */\nself.addEventListener(\"fetch\", event => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Skip non-GET requests for caching\n  if (request.method !== \"GET\") {\n    if (isAPIRequest(url)) {\n      // Handle API POST requests with intelligent offline behavior\n      event.respondWith(handleAPIRequest(request));\n    }\n    return;\n  }\n\n  // Route requests based on type\n  if (isAPIRequest(url)) {\n    event.respondWith(handleAPIRequest(request));\n  } else if (isStaticResource(url)) {\n    event.respondWith(handleStaticResource(request));\n  } else if (isAppShell(url)) {\n    event.respondWith(handleAppShell(request));\n  } else {\n    event.respondWith(handleRuntimeRequest(request));\n  }\n});\n\n/**\n * Handle API requests with medical data caching and bulletproof error handling\n */\nasync function handleAPIRequest(request) {\n  return safeAsync(\n    async () => {\n      const url = new URL(request.url);\n\n      // For POST requests (predictions), try network first with offline fallback\n      if (request.method === \"POST\") {\n        return await handlePredictionRequest(request);\n      }\n\n      // For GET requests, use stale-while-revalidate\n      const cache = await caches.open(API_CACHE_NAME);\n      const cachedResponse = await cache.match(request);\n\n      // If we have a cached response, return it while updating in background\n      if (cachedResponse) {\n        // Update cache in background with error handling\n        safeAsync(\n          async () => {\n            const response = await fetch(request);\n            if (response.ok) {\n              await cache.put(request, response.clone());\n            }\n          },\n          null,\n          { operation: \"background_cache_update\", url: request.url }\n        );\n\n        return cachedResponse;\n      }\n\n      // No cache, try network with timeout\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000);\n\n      try {\n        const networkResponse = await fetch(request, {\n          signal: controller.signal,\n        });\n        clearTimeout(timeoutId);\n\n        if (networkResponse.ok) {\n          // Cache response with error handling\n          try {\n            await cache.put(request, networkResponse.clone());\n          } catch (cacheError) {\n            console.warn(\"Failed to cache API response:\", cacheError.message);\n          }\n        }\n\n        return networkResponse;\n      } catch (fetchError) {\n        clearTimeout(timeoutId);\n        throw fetchError;\n      }\n    },\n    error => {\n      console.warn(\"API request failed, returning offline fallback:\", error.message);\n      return createOfflineFallbackResponse(request);\n    },\n    {\n      operation: \"api_request_handling\",\n      url: request.url,\n      method: request.method,\n    }\n  );\n}\n\n/**\n * Handle prediction API requests with intelligent offline support and bulletproof error handling\n */\nasync function handlePredictionRequest(request) {\n  return safeAsync(\n    async () => {\n      // Clone request for potential retry\n      const requestClone = request.clone();\n\n      // Try network first (critical for real-time predictions)\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout\n\n      try {\n        const networkResponse = await fetch(request, {\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n\n        if (networkResponse.ok) {\n          // Cache successful prediction for offline reference with error handling\n          safeAsync(\n            async () => {\n              const cache = await caches.open(API_CACHE_NAME);\n              const cacheKey = await createPredictionCacheKey(requestClone);\n\n              // Store with timestamp for freshness checking\n              const responseWithMetadata = await addCacheMetadata(networkResponse.clone());\n              await cache.put(cacheKey, responseWithMetadata);\n            },\n            null,\n            { operation: \"prediction_cache_storage\", url: request.url }\n          );\n\n          return networkResponse;\n        }\n\n        throw new Error(`API returned ${networkResponse.status}: ${networkResponse.statusText}`);\n      } catch (fetchError) {\n        clearTimeout(timeoutId);\n        throw fetchError;\n      }\n    },\n    async error => {\n      console.warn(\"Network prediction failed, trying offline alternatives:\", error.message);\n\n      // Try local LVO model if available\n      const localPrediction = await safeAsync(() => tryLocalPrediction(request), null, {\n        operation: \"local_prediction_attempt\",\n      });\n\n      if (localPrediction) {\n        return localPrediction;\n      }\n\n      // Return cached similar prediction if available\n      const cachedPrediction = await safeAsync(() => findSimilarCachedPrediction(request), null, {\n        operation: \"cached_prediction_lookup\",\n      });\n\n      if (cachedPrediction) {\n        return cachedPrediction;\n      }\n\n      // Return offline guidance response\n      return createOfflinePredictionGuidance();\n    },\n    {\n      operation: \"prediction_request_handling\",\n      url: request.url,\n    }\n  );\n}\n\n/**\n * Try local LVO prediction model when offline with comprehensive error handling\n */\nasync function tryLocalPrediction(request) {\n  return safeAsync(\n    async () => {\n      // Safe request body parsing\n      let data;\n      try {\n        const body = await request.text();\n        data = JSON.parse(body);\n      } catch (parseError) {\n        throw new Error(`Failed to parse request body: ${parseError.message}`);\n      }\n\n      // Validate required data\n      if (!data || typeof data !== \"object\") {\n        throw new Error(\"Invalid request data format\");\n      }\n\n      // Check if we can use local LVO model\n      if (request.url.includes(\"predict_full_stroke\")) {\n        // Validate required fields\n        if (!data.gfap_value || !data.fast_ed_score) {\n          throw new Error(\"Missing required fields for local LVO prediction\");\n        }\n\n        // Validate field ranges\n        if (data.gfap_value < 0 || data.gfap_value > 10000) {\n          throw new Error(\"GFAP value out of valid range\");\n        }\n\n        if (data.fast_ed_score < 0 || data.fast_ed_score > 10) {\n          throw new Error(\"FAST-ED score out of valid range\");\n        }\n\n        // Calculate local prediction with error handling\n        const localResult = calculateLocalLVO(data.gfap_value, data.fast_ed_score);\n\n        if (!localResult || typeof localResult !== \"object\") {\n          throw new Error(\"Local LVO calculation failed\");\n        }\n\n        return new Response(\n          JSON.stringify({\n            ...localResult,\n            source: \"local_model\",\n            offline: true,\n            timestamp: new Date().toISOString(),\n            warning:\n              \"This is an offline prediction using a simplified model. Seek professional medical advice.\",\n          }),\n          {\n            status: 200,\n            headers: { \"Content-Type\": \"application/json\" },\n          }\n        );\n      }\n\n      return null;\n    },\n    error => {\n      console.warn(\"Local prediction failed:\", error.message);\n      return null;\n    },\n    {\n      operation: \"local_prediction\",\n      url: request.url,\n    }\n  );\n}\n\n/**\n * Simplified local LVO calculation with safety checks\n */\nfunction calculateLocalLVO(gfap, fastEd) {\n  try {\n    // Input validation\n    if (typeof gfap !== \"number\" || typeof fastEd !== \"number\") {\n      throw new Error(\"GFAP and FAST-ED values must be numbers\");\n    }\n\n    if (!isFinite(gfap) || !isFinite(fastEd)) {\n      throw new Error(\"GFAP and FAST-ED values must be finite numbers\");\n    }\n\n    if (gfap < 0 || fastEd < 0) {\n      throw new Error(\"GFAP and FAST-ED values cannot be negative\");\n    }\n\n    // Simplified logic - in practice, this would use the full model\n    const gfapScore = gfap > 500 ? 0.4 : gfap > 200 ? 0.2 : 0.1;\n    const fastEdScore = fastEd >= 4 ? 0.5 : fastEd >= 2 ? 0.3 : 0.1;\n\n    const lvoProb = Math.min(0.95, gfapScore + fastEdScore);\n    const ichProb = Math.max(0.05, Math.min(0.5, gfap / 2000)); // Very conservative ICH estimate\n\n    // Validate calculated probabilities\n    if (\n      !isFinite(lvoProb) ||\n      !isFinite(ichProb) ||\n      lvoProb < 0 ||\n      lvoProb > 1 ||\n      ichProb < 0 ||\n      ichProb > 1\n    ) {\n      throw new Error(\"Calculated probabilities are invalid\");\n    }\n\n    return {\n      lvo: {\n        probability: Math.round(lvoProb * 100) / 100, // Round to 2 decimal places\n        confidence: 0.6, // Lower confidence for offline model\n        module: \"Local Offline Model\",\n        warning: \"Simplified offline calculation - not for clinical decisions\",\n      },\n      ich: {\n        probability: Math.round(ichProb * 100) / 100,\n        confidence: 0.4, // Very low confidence for ICH estimation\n        module: \"Local Offline Model\",\n        warning: \"Conservative estimate - seek immediate medical evaluation\",\n      },\n      metadata: {\n        calculatedAt: new Date().toISOString(),\n        inputs: { gfap, fastEd },\n        disclaimer:\n          \"This is a simplified offline model for emergency use only. Clinical judgment and professional medical evaluation are essential.\",\n      },\n    };\n  } catch (error) {\n    console.error(\"Local LVO calculation failed:\", error.message);\n\n    // Return safe fallback values\n    return {\n      lvo: {\n        probability: 0.1,\n        confidence: 0.1,\n        module: \"Emergency Fallback\",\n        error: \"Calculation failed - using minimum risk estimate\",\n      },\n      ich: {\n        probability: 0.1,\n        confidence: 0.1,\n        module: \"Emergency Fallback\",\n        error: \"Calculation failed - using minimum risk estimate\",\n      },\n      metadata: {\n        calculatedAt: new Date().toISOString(),\n        error: error.message,\n        disclaimer: \"Calculation failed. Immediate medical evaluation required.\",\n      },\n    };\n  }\n}\n\n/**\n * Handle static resources with cache-first strategy\n */\nasync function handleStaticResource(request) {\n  const cache = await caches.open(STATIC_CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n\n  if (cachedResponse) {\n    return cachedResponse;\n  }\n\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    // For critical resources, return a service unavailable response\n    return new Response(\"Service temporarily unavailable\", {\n      status: 503,\n      statusText: \"Service Unavailable\",\n    });\n  }\n}\n\n/**\n * Handle app shell with network-first, cache fallback\n */\nasync function handleAppShell(request) {\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      const cache = await caches.open(RUNTIME_CACHE_NAME);\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    const cache = await caches.open(STATIC_CACHE_NAME);\n    const cachedResponse = await cache.match(\"/0925/index.html\");\n\n    return (\n      cachedResponse ||\n      new Response(\"App temporarily unavailable\", {\n        status: 503,\n        statusText: \"Service Unavailable\",\n      })\n    );\n  }\n}\n\n/**\n * Handle runtime requests\n */\nasync function handleRuntimeRequest(request) {\n  const cache = await caches.open(RUNTIME_CACHE_NAME);\n\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok) {\n      cache.put(request, networkResponse.clone());\n    }\n\n    return networkResponse;\n  } catch (error) {\n    const cachedResponse = await cache.match(request);\n    return cachedResponse || fetch(request);\n  }\n}\n\n/**\n * Utility functions\n */\nfunction isAPIRequest(url) {\n  return API_ENDPOINTS.some(endpoint => url.href.startsWith(endpoint));\n}\n\nfunction isStaticResource(url) {\n  return (\n    url.pathname.includes(\"/src/\") ||\n    url.pathname.includes(\"/styles/\") ||\n    url.pathname.endsWith(\".css\") ||\n    url.pathname.endsWith(\".js\") ||\n    url.pathname.endsWith(\".png\") ||\n    url.pathname.endsWith(\".ico\")\n  );\n}\n\nfunction isAppShell(url) {\n  return (\n    url.pathname === \"/0925/\" || url.pathname === \"/0925/index.html\" || url.pathname.endsWith(\"/\")\n  );\n}\n\nasync function createPredictionCacheKey(request) {\n  const body = await request.text();\n  const hash = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(body));\n  const hashArray = Array.from(new Uint8Array(hash));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, \"0\")).join(\"\");\n\n  return `${request.url}#${hashHex}`;\n}\n\nasync function addCacheMetadata(response) {\n  const data = await response.json();\n  const responseWithMetadata = {\n    ...data,\n    _cached: true,\n    _cachedAt: Date.now(),\n    _cacheVersion: CACHE_VERSION,\n  };\n\n  return new Response(JSON.stringify(responseWithMetadata), {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n  });\n}\n\nasync function findSimilarCachedPrediction(request) {\n  // Implementation would find similar cached predictions\n  // This is a placeholder for more sophisticated matching\n  return null;\n}\n\nfunction createOfflineFallbackResponse(request) {\n  return new Response(\n    JSON.stringify({\n      error: \"Network unavailable\",\n      offline: true,\n      guidance:\n        \"Please check your network connection. For emergency situations, contact your local emergency services immediately.\",\n      timestamp: new Date().toISOString(),\n    }),\n    {\n      status: 503,\n      headers: { \"Content-Type\": \"application/json\" },\n    }\n  );\n}\n\nfunction createOfflinePredictionGuidance() {\n  return new Response(\n    JSON.stringify({\n      offline: true,\n      guidance: {\n        message:\n          \"Prediction services are currently unavailable. Please use clinical judgment and standard stroke protocols.\",\n        recommendations: [\n          \"Assess patient using standard NIHSS scoring\",\n          \"Consider time since symptom onset\",\n          \"Evaluate for contraindications to thrombolysis\",\n          \"Contact stroke team or neurologist if available\",\n          \"If in doubt, treat as potential stroke emergency\",\n        ],\n      },\n      emergency: \"For immediate emergency response, contact your local emergency services\",\n      timestamp: new Date().toISOString(),\n    }),\n    {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    }\n  );\n}\n\n/**\n * Background Sync for Medical Data\n */\nself.addEventListener(\"sync\", event => {\n  if (event.tag === \"medical-data-sync\") {\n    event.waitUntil(syncMedicalData());\n  }\n});\n\nasync function syncMedicalData() {\n  // Syncing medical data\n\n  try {\n    // Sync any pending medical data when connection is restored\n    // This would include patient data, predictions, etc.\n\n    // Notify clients of successful sync\n    const clients = await self.clients.matchAll();\n    clients.forEach(client => {\n      client.postMessage({\n        type: \"MEDICAL_DATA_SYNCED\",\n        timestamp: new Date().toISOString(),\n      });\n    });\n  } catch (error) {\n    // Medical data sync failed\n  }\n}\n\n/**\n * Push Notifications for Medical Alerts\n */\nself.addEventListener(\"push\", event => {\n  if (event.data) {\n    const data = event.data.json();\n\n    if (data.type === \"medical-alert\") {\n      event.waitUntil(showMedicalNotification(data));\n    }\n  }\n});\n\nasync function showMedicalNotification(data) {\n  const options = {\n    body: data.message,\n    icon: \"/0925/icon-192.png\",\n    badge: \"/0925/icon-192.png\",\n    vibrate: [200, 100, 200],\n    requireInteraction: true,\n    actions: [\n      {\n        action: \"view\",\n        title: \"View Details\",\n      },\n      {\n        action: \"dismiss\",\n        title: \"Dismiss\",\n      },\n    ],\n  };\n\n  await self.registration.showNotification(data.title, options);\n}\n\n/**\n * Notification Click Handler\n */\nself.addEventListener(\"notificationclick\", event => {\n  event.notification.close();\n\n  if (event.action === \"view\") {\n    event.waitUntil(self.clients.openWindow(\"/0925/\"));\n  }\n});\n\n/**\n * Message Handler for Communication with Main Thread\n */\nself.addEventListener(\"message\", event => {\n  const { type, data } = event.data;\n\n  switch (type) {\n  case \"SKIP_WAITING\":\n    self.skipWaiting();\n    break;\n\n  case \"GET_CACHE_STATUS\":\n    event.ports[0].postMessage(getCacheStatus());\n    break;\n\n  case \"CLEAR_CACHE\":\n    event.waitUntil(clearAllCaches());\n    break;\n\n  case \"PREFETCH_RESOURCES\":\n    event.waitUntil(prefetchResources(data.resources));\n    break;\n  }\n});\n\nasync function getCacheStatus() {\n  const caches = await self.caches.keys();\n  const status = {};\n\n  for (const cacheName of caches) {\n    const cache = await self.caches.open(cacheName);\n    const keys = await cache.keys();\n    status[cacheName] = keys.length;\n  }\n\n  return {\n    version: CACHE_VERSION,\n    caches: status,\n    timestamp: new Date().toISOString(),\n  };\n}\n\nasync function clearAllCaches() {\n  const cacheNames = await caches.keys();\n  await Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));\n\n  // All caches cleared\n}\n\nasync function prefetchResources(resources) {\n  const cache = await caches.open(RUNTIME_CACHE_NAME);\n\n  for (const resource of resources) {\n    try {\n      const response = await fetch(resource);\n      if (response.ok) {\n        await cache.put(resource, response);\n      }\n    } catch (error) {\n      // Failed to prefetch resource\n    }\n  }\n}\n\n// Medical Service Worker loaded\n"],"names":["safeAsync","operation","fallback","context","error","client","msgError","CACHE_VERSION","STATIC_CACHE_NAME","API_CACHE_NAME","RUNTIME_CACHE_NAME","CRITICAL_RESOURCES","API_ENDPOINTS","event","staticCache","successfulCaches","resource","response","fetchError","result","failedCaches","clientList","oldCaches","name","successfulCleanups","cacheName","deleted","_","reject","notificationPromises","request","url","isAPIRequest","handleAPIRequest","isStaticResource","handleStaticResource","isAppShell","handleAppShell","handleRuntimeRequest","handlePredictionRequest","cache","cachedResponse","controller","timeoutId","networkResponse","cacheError","createOfflineFallbackResponse","requestClone","cacheKey","createPredictionCacheKey","responseWithMetadata","addCacheMetadata","localPrediction","tryLocalPrediction","cachedPrediction","findSimilarCachedPrediction","createOfflinePredictionGuidance","data","body","parseError","localResult","calculateLocalLVO","gfap","fastEd","gfapScore","fastEdScore","lvoProb","ichProb","endpoint","hash","hashHex","b","syncMedicalData","showMedicalNotification","options","type","getCacheStatus","clearAllCaches","prefetchResources","caches","status","keys","cacheNames","resources"],"mappings":"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"}