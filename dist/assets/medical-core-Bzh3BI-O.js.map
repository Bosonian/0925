{"version":3,"file":"medical-core-Bzh3BI-O.js","sources":["../../src/state/store.js","../../src/logic/validate.js","../../src/patterns/observer.js","../../src/performance/medical-performance-monitor.js"],"sourcesContent":["// State management for the Stroke Triage Assistant\n\nclass Store {\n  constructor() {\n    this.state = {\n      currentScreen: \"login\",\n      results: null,\n      sessionId: null,\n      startTime: null,\n      formData: {},\n      validationErrors: {},\n      screenHistory: [],\n    };\n\n    this.listeners = new Set();\n    this.initialize();\n  }\n\n  initialize() {\n    this.state.sessionId = this.generateSessionId();\n    this.state.startTime = Date.now();\n  }\n\n  generateSessionId() {\n    const timestamp = Date.now();\n    try {\n      // Use cryptographically secure random values when available\n      if (typeof crypto !== \"undefined\" && crypto.getRandomValues) {\n        const randomBytes = new Uint8Array(8);\n        crypto.getRandomValues(randomBytes);\n        const randomHex = Array.from(randomBytes)\n          .map((b) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\");\n        return `session_${timestamp}_${randomHex}`;\n      }\n    } catch {}\n    // Fallback to Math.random when Web Crypto is unavailable\n    const fallback = Math.random().toString(36).slice(2, 10);\n    return `session_${timestamp}_${fallback}`;\n  }\n\n  // Subscribe to state changes\n  subscribe(listener) {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  // Notify all listeners of state changes\n  notify() {\n    console.log(`[Store] Notifying ${this.listeners.size} listeners of state change`);\n    this.listeners.forEach((listener) => listener(this.state));\n  }\n\n  // Get current state (read-only)\n  getState() {\n    return { ...this.state };\n  }\n\n  // Update state and notify listeners\n  setState(updates) {\n    this.state = { ...this.state, ...updates };\n    this.notify();\n  }\n\n  // Navigate to a new screen\n  navigate(screen) {\n    console.log(`[Store] navigate called: ${this.state.currentScreen} -> ${screen}`);\n    const history = [...this.state.screenHistory];\n\n    // Add current screen to history if not already there\n    if (this.state.currentScreen !== screen && !history.includes(this.state.currentScreen)) {\n      history.push(this.state.currentScreen);\n    }\n\n    const newState = {\n      currentScreen: screen,\n      screenHistory: history,\n    };\n\n    console.log(\"[Store] Setting new navigation state:\", newState);\n    this.setState(newState);\n    console.log(\"[Store] State after navigation:\", this.state.currentScreen);\n  }\n\n  // Navigate back to previous screen\n  goBack() {\n    const history = [...this.state.screenHistory];\n\n    if (history.length > 0) {\n      const previousScreen = history.pop();\n\n      this.setState({\n        currentScreen: previousScreen,\n        screenHistory: history,\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  // Navigate to home screen\n  goHome() {\n    this.setState({\n      currentScreen: \"triage1\",\n      screenHistory: [],\n    });\n  }\n\n  // Store form data for a specific module\n  setFormData(module, data) {\n    const formData = { ...this.state.formData };\n    formData[module] = { ...data };\n    this.setState({ formData });\n  }\n\n  // Get form data for a specific module\n  getFormData(module) {\n    return this.state.formData[module] || {};\n  }\n\n  // Store validation errors\n  setValidationErrors(errors) {\n    this.setState({ validationErrors: errors });\n  }\n\n  // Clear validation errors\n  clearValidationErrors() {\n    this.setState({ validationErrors: {} });\n  }\n\n  // Store prediction results\n  setResults(results) {\n    this.setState({ results });\n  }\n\n  // Check if there's unsaved data\n  hasUnsavedData() {\n    return Object.keys(this.state.formData).length > 0 && !this.state.results;\n  }\n\n  // Reset to initial state\n  reset() {\n    const newState = {\n      currentScreen: \"triage1\",\n      results: null,\n      sessionId: this.generateSessionId(),\n      startTime: Date.now(),\n      formData: {},\n      validationErrors: {},\n      screenHistory: [],\n    };\n    this.setState(newState);\n  }\n\n  // Log events for audit trail\n  logEvent(eventName, data = {}) {\n    const event = {\n      timestamp: Date.now(),\n      session: this.state.sessionId,\n      event: eventName,\n      data,\n    };\n\n    // In production, send to analytics service\n    // this.sendToAnalytics(event);\n  }\n\n  // Calculate session duration\n  getSessionDuration() {\n    return Date.now() - this.state.startTime;\n  }\n}\n\n// Create and export a singleton instance\nexport const store = new Store();\n\n// Export the Store class for testing purposes\nexport { Store };\n","import { VALIDATION_RULES } from \"../config.js\";\n\nexport function validateInput(name, value, rules, formData = null) {\n  const result = {\n    errors: [],\n    warnings: [],\n  };\n\n  if (rules.required && !value && value !== 0) {\n    result.errors.push(\"This field is required\");\n  }\n\n  if (rules.min !== undefined && value !== \"\" && !isNaN(value) && parseFloat(value) < rules.min) {\n    result.errors.push(`Value must be at least ${rules.min}`);\n  }\n\n  if (rules.max !== undefined && value !== \"\" && !isNaN(value) && parseFloat(value) > rules.max) {\n    result.errors.push(`Value must be at most ${rules.max}`);\n  }\n\n  if (rules.pattern && !rules.pattern.test(value)) {\n    result.errors.push(\"Invalid format\");\n  }\n\n  // Medical validation checks (warnings, not blocking errors)\n  if (rules.medicalCheck && value !== \"\" && !isNaN(value)) {\n    const medicalWarning = rules.medicalCheck(parseFloat(value), formData);\n    if (medicalWarning) {\n      result.warnings.push(medicalWarning);\n    }\n  }\n\n  // For backward compatibility, return just errors array if no warnings\n  if (result.warnings.length === 0) {\n    return result.errors;\n  }\n\n  return result;\n}\n\nexport function validateForm(form) {\n  let isValid = true;\n  const validationErrors = {};\n\n  // Collect form data for medical checks\n  const formData = {};\n  Object.keys(VALIDATION_RULES).forEach((name) => {\n    const input = form.elements[name];\n    if (input) {\n      formData[name] = input.value;\n    }\n  });\n\n  const validationWarnings = {};\n\n  Object.entries(VALIDATION_RULES).forEach(([name, rules]) => {\n    const input = form.elements[name];\n    if (input) {\n      const validation = validateInput(name, input.value, rules, formData);\n\n      // Handle both old format (array) and new format (object)\n      if (Array.isArray(validation)) {\n        // Old format - just errors\n        if (validation.length > 0) {\n          validationErrors[name] = validation;\n          isValid = false;\n        }\n      } else {\n        // New format - errors and warnings\n        if (validation.errors.length > 0) {\n          validationErrors[name] = validation.errors;\n          isValid = false;\n        }\n        if (validation.warnings.length > 0) {\n          validationWarnings[name] = validation.warnings;\n        }\n      }\n    }\n  });\n\n  return { isValid, validationErrors, validationWarnings };\n}\n\nexport function showValidationErrors(container, validationErrors) {\n  Object.entries(validationErrors).forEach(([name, errors]) => {\n    const input = container.querySelector(`[name=\"${name}\"]`);\n    if (input) {\n      const group = input.closest(\".input-group\");\n      if (group) {\n        group.classList.add(\"error\");\n        // Remove existing error messages\n        group.querySelectorAll(\".error-message\").forEach((el) => el.remove());\n        // Add new error message safely without innerHTML\n        const errorDiv = document.createElement(\"div\");\n        errorDiv.className = \"error-message\";\n\n        const iconSpan = document.createElement(\"span\");\n        iconSpan.className = \"error-icon\";\n        iconSpan.textContent = \"⚠️\";\n\n        errorDiv.appendChild(iconSpan);\n        errorDiv.appendChild(document.createTextNode(` ${errors[0]}`));\n        group.appendChild(errorDiv);\n      }\n    }\n  });\n}\n\nexport function showValidationWarnings(container, validationWarnings) {\n  Object.entries(validationWarnings).forEach(([name, warnings]) => {\n    const input = container.querySelector(`[name=\"${name}\"]`);\n    if (input) {\n      const group = input.closest(\".input-group\");\n      if (group) {\n        group.classList.add(\"warning\");\n        // Remove existing warning messages\n        group.querySelectorAll(\".warning-message\").forEach((el) => el.remove());\n        // Add new warning message safely without innerHTML\n        const warningDiv = document.createElement(\"div\");\n        warningDiv.className = \"warning-message\";\n\n        const iconSpan = document.createElement(\"span\");\n        iconSpan.className = \"warning-icon\";\n        iconSpan.textContent = \"💡\";\n\n        warningDiv.appendChild(iconSpan);\n        warningDiv.appendChild(document.createTextNode(` ${warnings[0]}`));\n        group.appendChild(warningDiv);\n      }\n    }\n  });\n}\n\nexport function clearValidationErrors(container) {\n  container.querySelectorAll(\".input-group.error\").forEach((group) => {\n    group.classList.remove(\"error\");\n    group.querySelectorAll(\".error-message\").forEach((el) => el.remove());\n  });\n}\n\nexport function clearValidationWarnings(container) {\n  container.querySelectorAll(\".input-group.warning\").forEach((group) => {\n    group.classList.remove(\"warning\");\n    group.querySelectorAll(\".warning-message\").forEach((el) => el.remove());\n  });\n}\n\nexport function clearAllValidation(container) {\n  clearValidationErrors(container);\n  clearValidationWarnings(container);\n}\n","/**\n * Observer Pattern Implementation for Medical Event Management\n * iGFAP Stroke Triage Assistant - Enterprise Architecture\n *\n * Provides secure, type-safe event handling for medical applications\n */\n\nexport class MedicalEventObserver {\n  constructor() {\n    this.observers = new Map();\n    this.eventHistory = [];\n    this.maxHistorySize = 1000;\n  }\n\n  /**\n   * Subscribe to medical events with validation\n   * @param {string} eventType - Medical event type\n   * @param {Function} callback - Observer callback function\n   * @param {Object} options - Observer options\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(eventType, callback, options = {}) {\n    if (typeof callback !== \"function\") {\n      throw new Error(\"Observer callback must be a function\");\n    }\n\n    if (!this.observers.has(eventType)) {\n      this.observers.set(eventType, new Set());\n    }\n\n    const observer = {\n      callback,\n      id: `obs_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      priority: options.priority || 0,\n      once: options.once || false,\n      medicalContext: options.medicalContext || null,\n    };\n\n    this.observers.get(eventType).add(observer);\n\n    // Return unsubscribe function\n    return () => {\n      const eventObservers = this.observers.get(eventType);\n      if (eventObservers) {\n        eventObservers.delete(observer);\n        if (eventObservers.size === 0) {\n          this.observers.delete(eventType);\n        }\n      }\n    };\n  }\n\n  /**\n   * Publish medical events with safety checks\n   * @param {string} eventType - Medical event type\n   * @param {Object} data - Event data\n   * @param {Object} metadata - Event metadata\n   */\n  publish(eventType, data = {}, metadata = {}) {\n    const eventObservers = this.observers.get(eventType);\n    if (!eventObservers || eventObservers.size === 0) {\n      return;\n    }\n\n    const event = {\n      type: eventType,\n      data: this.sanitizeEventData(data),\n      metadata: {\n        timestamp: new Date().toISOString(),\n        source: \"MedicalEventObserver\",\n        ...metadata,\n      },\n      id: `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    };\n\n    // Log event for medical audit trail\n    this.logEvent(event);\n\n    // Sort observers by priority (higher priority first)\n    const sortedObservers = Array.from(eventObservers).sort((a, b) => b.priority - a.priority);\n\n    // Notify observers with error handling\n    sortedObservers.forEach((observer) => {\n      try {\n        observer.callback(event);\n\n        // Remove one-time observers\n        if (observer.once) {\n          eventObservers.delete(observer);\n        }\n      } catch (error) {\n        // (`Medical observer error for event ${eventType}:`, error);\n        // Don't propagate observer errors to prevent cascade failures\n      }\n    });\n  }\n\n  /**\n   * Sanitize event data to prevent sensitive information leakage\n   * @param {Object} data - Raw event data\n   * @returns {Object} Sanitized data\n   */\n  sanitizeEventData(data) {\n    const sensitiveFields = [\"password\", \"ssn\", \"medical_record_number\", \"patient_id\"];\n    const sanitized = { ...data };\n\n    sensitiveFields.forEach((field) => {\n      if (sanitized[field]) {\n        sanitized[field] = \"[REDACTED]\";\n      }\n    });\n\n    return sanitized;\n  }\n\n  /**\n   * Log event for medical audit trail\n   * @param {Object} event - Event to log\n   */\n  logEvent(event) {\n    this.eventHistory.push({\n      ...event,\n      loggedAt: new Date().toISOString(),\n    });\n\n    // Maintain history size limit\n    if (this.eventHistory.length > this.maxHistorySize) {\n      this.eventHistory.shift();\n    }\n  }\n\n  /**\n   * Get event history for audit purposes\n   * @param {string} eventType - Optional event type filter\n   * @returns {Array} Event history\n   */\n  getEventHistory(eventType = null) {\n    if (eventType) {\n      return this.eventHistory.filter((event) => event.type === eventType);\n    }\n    return [...this.eventHistory];\n  }\n\n  /**\n   * Clear all observers and history (for privacy compliance)\n   */\n  clearAll() {\n    this.observers.clear();\n    this.eventHistory = [];\n  }\n\n  /**\n   * Get observer statistics for monitoring\n   * @returns {Object} Observer statistics\n   */\n  getStats() {\n    const stats = {\n      totalEventTypes: this.observers.size,\n      totalObservers: 0,\n      eventHistory: this.eventHistory.length,\n      eventTypes: {},\n    };\n\n    this.observers.forEach((observers, eventType) => {\n      stats.totalObservers += observers.size;\n      stats.eventTypes[eventType] = observers.size;\n    });\n\n    return stats;\n  }\n}\n\n// Medical event types constants\nexport const MEDICAL_EVENTS = {\n  // Patient data events\n  PATIENT_DATA_UPDATED: \"patient_data_updated\",\n  VALIDATION_ERROR: \"validation_error\",\n  VALIDATION_SUCCESS: \"validation_success\",\n\n  // Clinical workflow events\n  TRIAGE_COMPLETED: \"triage_completed\",\n  ASSESSMENT_STARTED: \"assessment_started\",\n  RESULTS_GENERATED: \"results_generated\",\n\n  // System events\n  PERFORMANCE_WARNING: \"performance_warning\",\n  SECURITY_EVENT: \"security_event\",\n  AUDIT_EVENT: \"audit_event\",\n\n  // User interaction events\n  FORM_SUBMITTED: \"form_submitted\",\n  NAVIGATION_CHANGED: \"navigation_changed\",\n  SESSION_TIMEOUT: \"session_timeout\",\n};\n\n// Export singleton instance\nexport const medicalEventObserver = new MedicalEventObserver();\n","/**\n * Medical Performance Monitoring System\n * iGFAP Stroke Triage Assistant - Enterprise Performance Architecture\n *\n * Provides comprehensive performance monitoring for medical software compliance\n */\n\nimport { medicalEventObserver, MEDICAL_EVENTS } from \"../patterns/observer.js\";\n\n/**\n * Performance metric types for medical applications\n */\nexport const PerformanceMetricType = {\n  API_CALL: \"api_call\",\n  VALIDATION: \"validation\",\n  PREDICTION: \"prediction\",\n  RENDER: \"render\",\n  USER_INTERACTION: \"user_interaction\",\n  MEMORY: \"memory\",\n  NETWORK: \"network\",\n  CACHE: \"cache\",\n};\n\n/**\n * Performance thresholds for medical critical operations\n */\nexport const MedicalPerformanceThresholds = {\n  CRITICAL_API_RESPONSE: 3000, // 3 seconds max for critical medical APIs\n  VALIDATION_RESPONSE: 100, // 100ms max for form validation\n  PREDICTION_RESPONSE: 5000, // 5 seconds max for ML predictions\n  UI_RENDER: 16, // 16ms for 60fps smooth UI\n  USER_INTERACTION: 100, // 100ms max for immediate feedback\n  MEMORY_LEAK_THRESHOLD: 50 * 1024 * 1024, // 50MB memory increase\n};\n\n/**\n * Performance metric data structure\n */\nclass PerformanceMetric {\n  constructor(type, name, startTime = performance.now()) {\n    this.type = type;\n    this.name = name;\n    this.startTime = startTime;\n    this.endTime = null;\n    this.duration = null;\n    this.metadata = {};\n    this.id = `perf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    this.timestamp = new Date().toISOString();\n  }\n\n  /**\n   * Mark the end of the performance measurement\n   */\n  end() {\n    this.endTime = performance.now();\n    this.duration = this.endTime - this.startTime;\n    return this;\n  }\n\n  /**\n   * Add metadata to the metric\n   */\n  addMetadata(key, value) {\n    this.metadata[key] = value;\n    return this;\n  }\n\n  /**\n   * Check if metric exceeds threshold\n   */\n  exceedsThreshold() {\n    const threshold = MedicalPerformanceThresholds[this.getThresholdKey()];\n    return threshold && this.duration > threshold;\n  }\n\n  /**\n   * Get the appropriate threshold key for this metric\n   */\n  getThresholdKey() {\n    switch (this.type) {\n    case PerformanceMetricType.API_CALL:\n      return this.metadata.critical ? \"CRITICAL_API_RESPONSE\" : \"PREDICTION_RESPONSE\";\n    case PerformanceMetricType.VALIDATION:\n      return \"VALIDATION_RESPONSE\";\n    case PerformanceMetricType.PREDICTION:\n      return \"PREDICTION_RESPONSE\";\n    case PerformanceMetricType.RENDER:\n      return \"UI_RENDER\";\n    case PerformanceMetricType.USER_INTERACTION:\n      return \"USER_INTERACTION\";\n    default:\n      return null;\n    }\n  }\n\n  /**\n   * Get performance grade based on thresholds\n   */\n  getPerformanceGrade() {\n    const threshold = MedicalPerformanceThresholds[this.getThresholdKey()];\n    if (!threshold) {\n      return \"N/A\";\n    }\n\n    const ratio = this.duration / threshold;\n    if (ratio <= 0.5) {\n      return \"EXCELLENT\";\n    }\n    if (ratio <= 0.75) {\n      return \"GOOD\";\n    }\n    if (ratio <= 1.0) {\n      return \"ACCEPTABLE\";\n    }\n    if (ratio <= 1.5) {\n      return \"WARNING\";\n    }\n    return \"CRITICAL\";\n  }\n}\n\n/**\n * Medical Performance Monitor for enterprise-grade monitoring\n */\nexport class MedicalPerformanceMonitor {\n  constructor() {\n    this.metrics = new Map();\n    this.activeMetrics = new Map();\n    this.memoryBaseline = null;\n    this.performanceObserver = null;\n    this.isMonitoring = false;\n    this.reportingInterval = null;\n    this.config = {\n      reportingIntervalMs: 30000, // Report every 30 seconds\n      maxMetricsRetention: 1000, // Keep last 1000 metrics\n      enableMemoryMonitoring: true,\n      enableNetworkMonitoring: true,\n      enableUserTimingAPI: true,\n    };\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  start() {\n    if (this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = true;\n    this.memoryBaseline = this.getMemoryUsage();\n\n    // Initialize Performance Observer API if available\n    if (window.PerformanceObserver) {\n      this.initializePerformanceObserver();\n    }\n\n    // Start periodic reporting\n    this.reportingInterval = setInterval(() => {\n      this.generatePerformanceReport();\n    }, this.config.reportingIntervalMs);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: \"performance_monitoring_started\",\n      memoryBaseline: this.memoryBaseline,\n    });\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  stop() {\n    if (!this.isMonitoring) {\n      return;\n    }\n\n    this.isMonitoring = false;\n\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n      this.performanceObserver = null;\n    }\n\n    if (this.reportingInterval) {\n      clearInterval(this.reportingInterval);\n      this.reportingInterval = null;\n    }\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: \"performance_monitoring_stopped\",\n      totalMetrics: this.metrics.size,\n    });\n  }\n\n  /**\n   * Initialize Performance Observer for automatic metric collection\n   */\n  initializePerformanceObserver() {\n    try {\n      this.performanceObserver = new PerformanceObserver((list) => {\n        list.getEntries().forEach((entry) => {\n          this.recordPerformanceEntry(entry);\n        });\n      });\n\n      // Observe different types of performance entries\n      this.performanceObserver.observe({ entryTypes: [\"measure\", \"navigation\", \"resource\"] });\n    } catch (error) {\n      // ('Performance Observer not supported:', error.message);\n    }\n  }\n\n  /**\n   * Record performance entry from Performance Observer\n   */\n  recordPerformanceEntry(entry) {\n    let metricType = PerformanceMetricType.NETWORK;\n    let { name } = entry;\n\n    // Categorize based on entry type\n    switch (entry.entryType) {\n    case \"navigation\":\n      metricType = PerformanceMetricType.RENDER;\n      name = \"page_load\";\n      break;\n    case \"resource\":\n      metricType = entry.name.includes(\"/api/\") ? PerformanceMetricType.API_CALL : PerformanceMetricType.NETWORK;\n      break;\n    case \"measure\":\n      metricType = this.categorizeUserMeasure(entry.name);\n      break;\n    }\n\n    const metric = new PerformanceMetric(metricType, name, entry.startTime);\n    metric.end();\n    metric.duration = entry.duration;\n    metric.addMetadata(\"entryType\", entry.entryType);\n\n    this.storeMetric(metric);\n  }\n\n  /**\n   * Categorize user-defined measures\n   */\n  categorizeUserMeasure(name) {\n    if (name.includes(\"validation\")) {\n      return PerformanceMetricType.VALIDATION;\n    }\n    if (name.includes(\"prediction\")) {\n      return PerformanceMetricType.PREDICTION;\n    }\n    if (name.includes(\"render\")) {\n      return PerformanceMetricType.RENDER;\n    }\n    if (name.includes(\"api\")) {\n      return PerformanceMetricType.API_CALL;\n    }\n    return PerformanceMetricType.USER_INTERACTION;\n  }\n\n  /**\n   * Start measuring a performance metric\n   */\n  startMeasurement(type, name, metadata = {}) {\n    const metric = new PerformanceMetric(type, name);\n\n    // Add initial metadata\n    Object.entries(metadata).forEach(([key, value]) => {\n      metric.addMetadata(key, value);\n    });\n\n    this.activeMetrics.set(metric.id, metric);\n\n    // Also use User Timing API if enabled and available\n    if (this.config.enableUserTimingAPI && performance.mark) {\n      performance.mark(`${name}_start`);\n    }\n\n    return metric.id;\n  }\n\n  /**\n   * End measuring a performance metric\n   */\n  endMeasurement(metricId, additionalMetadata = {}) {\n    const metric = this.activeMetrics.get(metricId);\n    if (!metric) {\n      // (`Performance metric ${metricId} not found`);\n      return null;\n    }\n\n    metric.end();\n\n    // Add additional metadata\n    Object.entries(additionalMetadata).forEach(([key, value]) => {\n      metric.addMetadata(key, value);\n    });\n\n    // Use User Timing API if enabled\n    if (this.config.enableUserTimingAPI && performance.mark && performance.measure) {\n      try {\n        performance.mark(`${metric.name}_end`);\n        performance.measure(metric.name, `${metric.name}_start`, `${metric.name}_end`);\n      } catch (error) {\n        // ('Error creating performance measure:', error.message);\n      }\n    }\n\n    this.activeMetrics.delete(metricId);\n    this.storeMetric(metric);\n\n    // Check for performance violations\n    if (metric.exceedsThreshold()) {\n      this.handlePerformanceViolation(metric);\n    }\n\n    return metric;\n  }\n\n  /**\n   * Store metric with retention limits\n   */\n  storeMetric(metric) {\n    this.metrics.set(metric.id, metric);\n\n    // Implement retention policy\n    if (this.metrics.size > this.config.maxMetricsRetention) {\n      const oldestKey = this.metrics.keys().next().value;\n      this.metrics.delete(oldestKey);\n    }\n\n    // Publish metric event\n    medicalEventObserver.publish(MEDICAL_EVENTS.PERFORMANCE_METRIC, {\n      metric: {\n        id: metric.id,\n        type: metric.type,\n        name: metric.name,\n        duration: metric.duration,\n        grade: metric.getPerformanceGrade(),\n        exceedsThreshold: metric.exceedsThreshold(),\n      },\n    });\n  }\n\n  /**\n   * Handle performance violations\n   */\n  handlePerformanceViolation(metric) {\n    const violation = {\n      metricId: metric.id,\n      type: metric.type,\n      name: metric.name,\n      duration: metric.duration,\n      threshold: MedicalPerformanceThresholds[metric.getThresholdKey()],\n      grade: metric.getPerformanceGrade(),\n      metadata: metric.metadata,\n    };\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.PERFORMANCE_VIOLATION, violation);\n\n    // Log critical violations\n    if (metric.getPerformanceGrade() === \"CRITICAL\") {\n      // ('CRITICAL PERFORMANCE VIOLATION:', violation);\n    }\n  }\n\n  /**\n   * Get current memory usage\n   */\n  getMemoryUsage() {\n    if (performance.memory) {\n      return {\n        usedJSHeapSize: performance.memory.usedJSHeapSize,\n        totalJSHeapSize: performance.memory.totalJSHeapSize,\n        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,\n        timestamp: Date.now(),\n      };\n    }\n    return null;\n  }\n\n  /**\n   * Check for memory leaks\n   */\n  checkMemoryLeaks() {\n    if (!this.config.enableMemoryMonitoring || !this.memoryBaseline) {\n      return null;\n    }\n\n    const currentMemory = this.getMemoryUsage();\n    if (!currentMemory) {\n      return null;\n    }\n\n    const memoryIncrease = currentMemory.usedJSHeapSize - this.memoryBaseline.usedJSHeapSize;\n    const isLeak = memoryIncrease > MedicalPerformanceThresholds.MEMORY_LEAK_THRESHOLD;\n\n    if (isLeak) {\n      medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n        action: \"memory_leak_detected\",\n        memoryIncrease,\n        baseline: this.memoryBaseline.usedJSHeapSize,\n        current: currentMemory.usedJSHeapSize,\n      });\n    }\n\n    return {\n      memoryIncrease,\n      isLeak,\n      baseline: this.memoryBaseline,\n      current: currentMemory,\n    };\n  }\n\n  /**\n   * Generate comprehensive performance report\n   */\n  generatePerformanceReport() {\n    const metrics = Array.from(this.metrics.values());\n    const now = Date.now();\n    const lastHour = now - (60 * 60 * 1000);\n\n    // Filter metrics from last hour\n    const recentMetrics = metrics.filter((m) => new Date(m.timestamp).getTime() > lastHour);\n\n    // Group by type\n    const metricsByType = recentMetrics.reduce((acc, metric) => {\n      if (!acc[metric.type]) {\n        acc[metric.type] = [];\n      }\n      acc[metric.type].push(metric);\n      return acc;\n    }, {});\n\n    // Calculate statistics\n    const report = {\n      timestamp: new Date().toISOString(),\n      timeframe: \"last_hour\",\n      totalMetrics: recentMetrics.length,\n      memoryStatus: this.checkMemoryLeaks(),\n      metricsByType: {},\n      violations: recentMetrics.filter((m) => m.exceedsThreshold()).length,\n      topSlowOperations: this.getTopSlowOperations(recentMetrics),\n    };\n\n    // Calculate statistics for each type\n    Object.entries(metricsByType).forEach(([type, typeMetrics]) => {\n      const durations = typeMetrics.map((m) => m.duration);\n      const grades = typeMetrics.map((m) => m.getPerformanceGrade());\n\n      report.metricsByType[type] = {\n        count: typeMetrics.length,\n        averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,\n        medianDuration: this.calculateMedian(durations),\n        minDuration: Math.min(...durations),\n        maxDuration: Math.max(...durations),\n        violations: typeMetrics.filter((m) => m.exceedsThreshold()).length,\n        gradeDistribution: this.calculateGradeDistribution(grades),\n      };\n    });\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.PERFORMANCE_REPORT, report);\n\n    return report;\n  }\n\n  /**\n   * Calculate median value\n   */\n  calculateMedian(values) {\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    return sorted.length % 2 === 0\n      ? (sorted[mid - 1] + sorted[mid]) / 2\n      : sorted[mid];\n  }\n\n  /**\n   * Calculate grade distribution\n   */\n  calculateGradeDistribution(grades) {\n    return grades.reduce((acc, grade) => {\n      acc[grade] = (acc[grade] || 0) + 1;\n      return acc;\n    }, {});\n  }\n\n  /**\n   * Get top slow operations\n   */\n  getTopSlowOperations(metrics, limit = 10) {\n    return metrics\n      .sort((a, b) => b.duration - a.duration)\n      .slice(0, limit)\n      .map((m) => ({\n        name: m.name,\n        type: m.type,\n        duration: m.duration,\n        grade: m.getPerformanceGrade(),\n        timestamp: m.timestamp,\n      }));\n  }\n\n  /**\n   * Get performance statistics for specific type\n   */\n  getTypeStatistics(type, timeframeMs = 60 * 60 * 1000) {\n    const now = Date.now();\n    const cutoff = now - timeframeMs;\n\n    const typeMetrics = Array.from(this.metrics.values())\n      .filter((m) => m.type === type && new Date(m.timestamp).getTime() > cutoff);\n\n    if (typeMetrics.length === 0) {\n      return null;\n    }\n\n    const durations = typeMetrics.map((m) => m.duration);\n    return {\n      type,\n      count: typeMetrics.length,\n      averageDuration: durations.reduce((a, b) => a + b, 0) / durations.length,\n      medianDuration: this.calculateMedian(durations),\n      minDuration: Math.min(...durations),\n      maxDuration: Math.max(...durations),\n      violations: typeMetrics.filter((m) => m.exceedsThreshold()).length,\n    };\n  }\n\n  /**\n   * Clear all metrics (privacy compliance)\n   */\n  clearMetrics() {\n    this.metrics.clear();\n    this.activeMetrics.clear();\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.AUDIT_EVENT, {\n      action: \"performance_metrics_cleared\",\n    });\n  }\n\n  /**\n   * Get monitor configuration\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n\n  /**\n   * Update monitor configuration\n   */\n  updateConfig(newConfig) {\n    this.config = { ...this.config, ...newConfig };\n\n    // Restart reporting interval if changed\n    if (newConfig.reportingIntervalMs && this.reportingInterval) {\n      clearInterval(this.reportingInterval);\n      this.reportingInterval = setInterval(() => {\n        this.generatePerformanceReport();\n      }, this.config.reportingIntervalMs);\n    }\n  }\n}\n\n// Export singleton instance\nexport const medicalPerformanceMonitor = new MedicalPerformanceMonitor();\n"],"names":["Store","timestamp","randomBytes","randomHex","b","e","fallback","listener","updates","screen","history","newState","previousScreen","module","data","formData","errors","results","eventName","store","validateInput","name","value","rules","result","medicalWarning","validateForm","form","isValid","validationErrors","VALIDATION_RULES","input","validationWarnings","validation","showValidationErrors","container","group","el","errorDiv","iconSpan","MedicalEventObserver","eventType","callback","options","observer","eventObservers","metadata","event","a","error","sensitiveFields","sanitized","field","stats","observers","MEDICAL_EVENTS","medicalEventObserver","PerformanceMetricType","MedicalPerformanceThresholds","PerformanceMetric","type","startTime","key","threshold","ratio","MedicalPerformanceMonitor","list","entry","metricType","metric","metricId","additionalMetadata","oldestKey","violation","currentMemory","memoryIncrease","isLeak","metrics","lastHour","recentMetrics","m","metricsByType","acc","report","typeMetrics","durations","grades","values","sorted","mid","grade","limit","timeframeMs","cutoff","newConfig","medicalPerformanceMonitor"],"mappings":"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"}