{"version":3,"file":"prediction-models-D4Bj5_qH.js","sources":["../../src/api/client.js","../../src/logic/ich-volume-calculator.js"],"sourcesContent":["/**\r\n * Medical Prediction API Client - Refactored for Enterprise Architecture\r\n * Eliminates code duplication using BasePredictionClient patterns\r\n *\r\n * Key improvements:\r\n * - Single source of truth for API logic\r\n * - Consistent error handling across all endpoints\r\n * - DRY principle enforcement\r\n * - Enhanced medical validation\r\n * - Enterprise-grade logging and monitoring\r\n *\r\n * @author iGFAP Project Team\r\n * @contact Deepak Bos <bosdeepak@gmail.com>\r\n */\r\n\r\nimport { API_URLS, APP_CONFIG, DEV_CONFIG } from '../config.js';\r\nimport { lvoProbability, lvoClass } from '../lib/lvoModel.js';\r\n\r\nimport { extractDriversFromResponse, extractProbabilityFromResponse, extractConfidenceFromResponse } from './drivers.js';\r\n\r\n// APIError class for medical API errors\r\nexport class APIError extends Error {\r\n  constructor(message, status, url) {\r\n    super(message);\r\n    this.name = 'APIError';\r\n    this.status = status;\r\n    this.url = url;\r\n  }\r\n}\r\n\r\n// MedicalAPIError class (same as APIError for compatibility)\r\nexport class MedicalAPIError extends APIError {\r\n  constructor(message, status, url) {\r\n    super(message, status, url);\r\n    this.name = 'MedicalAPIError';\r\n  }\r\n}\r\n\r\n// Helper function to format drivers from flat dictionary\r\nfunction formatDriversFromDict(drivers, predictionType) {\r\n  if (!drivers || typeof drivers !== 'object') {\r\n    return null;\r\n  }\r\n\r\n  const positive = [];\r\n  const negative = [];\r\n\r\n  Object.entries(drivers).forEach(([label, weight]) => {\r\n    if (typeof weight === 'number') {\r\n      if (weight > 0) {\r\n        positive.push({ label, weight });\r\n      } else if (weight < 0) {\r\n        negative.push({ label, weight: Math.abs(weight) });\r\n      }\r\n    }\r\n  });\r\n\r\n  // Sort by weight (descending)\r\n  positive.sort((a, b) => b.weight - a.weight);\r\n  negative.sort((a, b) => b.weight - a.weight);\r\n\r\n  return {\r\n    kind: 'flat_dictionary',\r\n    units: 'logit',\r\n    positive,\r\n    negative,\r\n    meta: {},\r\n  };\r\n}\r\n\r\n// Helper functions to replace basePredictionClient functionality\r\nconst clientHelpers = {\r\n  safeParseFloat: (value, defaultValue = 0) => {\r\n    const parsed = parseFloat(value);\r\n    return isNaN(parsed) ? defaultValue : parsed;\r\n  },\r\n\r\n  normalizeBooleans: (payload) => {\r\n    const normalized = { ...payload };\r\n    Object.keys(normalized).forEach((key) => {\r\n      if (normalized[key] === 'true' || normalized[key] === true) {\r\n        normalized[key] = 1;\r\n      } else if (normalized[key] === 'false' || normalized[key] === false) {\r\n        normalized[key] = 0;\r\n      }\r\n    });\r\n    return normalized;\r\n  },\r\n\r\n  async makeApiCall(endpoint, payload, endpointType = 'unknown') {\r\n    console.log(`[API] Making ${endpointType} request to:`, endpoint);\r\n    console.log('[API] Payload:', payload);\r\n\r\n    try {\r\n      const controller = new AbortController();\r\n      const timeout = endpoint.includes('full_stroke') ? 15000 : 8000;\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      const normalizedPayload = this.normalizeBooleans(payload);\r\n\r\n      const response = await fetch(endpoint, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          Accept: 'application/json',\r\n        },\r\n        body: JSON.stringify(normalizedPayload),\r\n        signal: controller.signal,\r\n        mode: 'cors',\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text().catch(() => 'Network error');\r\n        throw new MedicalAPIError(\r\n          `API request failed: ${response.status} ${response.statusText} - ${errorText}`,\r\n          response.status,\r\n          endpoint,\r\n        );\r\n      }\r\n\r\n      const result = await response.json();\r\n      console.log(`[API] ${endpointType} response:`, result);\r\n      console.log(`[API] ${endpointType} response keys:`, Object.keys(result));\r\n      console.log(`[API] ${endpointType} first key:`, Object.keys(result)[0]);\r\n      console.log(`[API] ${endpointType} first value:`, result[Object.keys(result)[0]]);\r\n      console.log(`[API] ${endpointType} probability:`, result.probability);\r\n      console.log(`[API] ${endpointType} ich_probability:`, result.ich_probability);\r\n\r\n      // Normalize response: some APIs return \"ich_probability\" instead of \"probability\"\r\n      if (!result.probability && result.ich_probability !== undefined) {\r\n        result.probability = result.ich_probability;\r\n        console.log(`[API] ${endpointType} normalized probability from ich_probability:`, result.probability);\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      if (error.name === 'AbortError') {\r\n        console.warn(`[API] ${endpointType} request timeout`);\r\n        throw new MedicalAPIError(`Request timeout after ${timeout / 1000}s`, 408, endpoint);\r\n      }\r\n\r\n      if (error instanceof MedicalAPIError) {\r\n        throw error;\r\n      }\r\n\r\n      console.error(`[API] ${endpointType} request failed:`, error);\r\n      throw new MedicalAPIError(\r\n        `Network error: ${error.message}`,\r\n        0,\r\n        endpoint,\r\n      );\r\n    }\r\n  },\r\n\r\n  getRequestStats: () => ({ requests: 0, errors: 0, avgResponseTime: 0 }),\r\n  cancelAllRequests: () => console.log('Cancel requests - not implemented'),\r\n\r\n  async predict(moduleType, payload) {\r\n    const endpointMap = {\r\n      coma_ich: API_URLS.COMA_ICH,\r\n      limited_ich: API_URLS.LDM_ICH,\r\n      full_stroke: API_URLS.FULL_STROKE,\r\n      lvo: API_URLS.LVO_PREDICTION,\r\n    };\r\n\r\n    const endpoint = endpointMap[moduleType];\r\n    if (!endpoint) {\r\n      throw new MedicalAPIError(`Unknown module type: ${moduleType}`, 400, 'unknown');\r\n    }\r\n\r\n    return await this.makeApiCall(endpoint, payload, moduleType);\r\n  },\r\n};\r\n\r\n/**\r\n * Warm up Google Cloud Functions on app load\r\n * Optimized for production reliability\r\n */\r\nexport async function warmUpFunctions() {\r\n  console.log('Warming up Cloud Functions...');\r\n\r\n  const prioritizedUrls = [\r\n    API_URLS.FULL_STROKE, // Warm this first - most complex\r\n    API_URLS.LVO_PREDICTION, // New LVO endpoint\r\n    API_URLS.COMA_ICH,\r\n    API_URLS.LDM_ICH,\r\n    API_URLS.AUTHENTICATE,\r\n  ];\r\n\r\n  const warmUpPromises = prioritizedUrls.map(async (url, index) => {\r\n    await new Promise((resolve) => setTimeout(resolve, index * 200));\r\n\r\n    try {\r\n      const controller = new AbortController();\r\n      const timeout = url.includes('full_stroke') ? 8000 : 3000;\r\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\r\n\r\n      await fetch(url, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({}),\r\n        signal: controller.signal,\r\n        mode: 'cors',\r\n      });\r\n\r\n      clearTimeout(timeoutId);\r\n      console.log(`‚úì Warmed up: ${url.split('/').pop()}`);\r\n    } catch (error) {\r\n      console.log(`‚úì Warm-up attempt for ${url.split('/').pop()} completed`);\r\n    }\r\n  });\r\n\r\n  Promise.all(warmUpPromises).then(() => {\r\n    console.log('‚úÖ Cloud Functions warm-up complete');\r\n  }).catch(() => {\r\n    // Silently handle errors\r\n  });\r\n}\r\n\r\n/**\r\n * COMA ICH Prediction - Refactored to use BasePredictionClient\r\n * @param {Object} payload - Patient data for coma module\r\n * @returns {Promise<Object>} ICH prediction result\r\n */\r\nexport async function predictComaIch(payload) {\r\n  try {\r\n    return await clientHelpers.predict('coma_ich', payload);\r\n  } catch (error) {\r\n    // Transform MedicalAPIError back to APIError for backward compatibility\r\n    if (error instanceof MedicalAPIError) {\r\n      const apiError = new Error(error.message);\r\n      apiError.name = 'APIError';\r\n      apiError.status = error.status;\r\n      apiError.url = error.url;\r\n      throw apiError;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Limited Data ICH Prediction - Refactored to use BasePredictionClient\r\n * @param {Object} payload - Patient data for limited data module\r\n * @returns {Promise<Object>} ICH prediction result\r\n */\r\nexport async function predictLimitedIch(payload) {\r\n  try {\r\n    return await clientHelpers.predict('limited_ich', payload);\r\n  } catch (error) {\r\n    if (error instanceof MedicalAPIError) {\r\n      const apiError = new Error(error.message);\r\n      apiError.name = 'APIError';\r\n      apiError.status = error.status;\r\n      apiError.url = error.url;\r\n      throw apiError;\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * LVO Prediction with Enhanced Fallback Logic\r\n * @param {Object} payload - Patient data for LVO assessment\r\n * @param {number} retryCount - Retry attempt counter\r\n * @returns {Promise<Object>} LVO prediction result\r\n */\r\nexport async function predictLVO(payload, retryCount = 0) {\r\n  console.log('[API] predictLVO called with payload:', payload);\r\n\r\n  if (!payload.gfap_value || !payload.fast_ed_score) {\r\n    throw new MedicalAPIError(\r\n      'Missing required parameters: gfap_value and fast_ed_score',\r\n      400,\r\n      API_URLS.LVO_PREDICTION,\r\n    );\r\n  }\r\n\r\n  console.log('[API] LVO payload preparation...');\r\n\r\n  try {\r\n    // Try enterprise client first\r\n    console.log('üå©Ô∏è Using LVO Cloud Function (primary)');\r\n    const result = await clientHelpers.predict('lvo', payload);\r\n    console.log('[API] LVO Cloud Function response:', result);\r\n    return result;\r\n  } catch (error) {\r\n    console.warn('‚ö†Ô∏è LVO Cloud Function failed, falling back to local model:', error.message);\r\n    console.log('üè† Using New LVO Model (fallback)');\r\n\r\n    try {\r\n      const gfapValue = parseFloat(payload.gfap_value);\r\n      const fastEdScore = parseInt(payload.fast_ed_score);\r\n\r\n      if (isNaN(gfapValue) || isNaN(fastEdScore)) {\r\n        throw new Error('Invalid GFAP or FAST-ED values');\r\n      }\r\n\r\n      const probability = lvoProbability(gfapValue, fastEdScore);\r\n      const classification = lvoClass(gfapValue, fastEdScore);\r\n\r\n      const drivers = {\r\n        kind: 'new_model_fallback',\r\n        units: 'normalized_contribution',\r\n        positive: [\r\n          { label: 'GFAP Biomarker', weight: gfapValue > 100 ? 0.6 : 0.3 },\r\n          { label: 'FAST-ED Score', weight: fastEdScore * 0.1 },\r\n        ].sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)),\r\n        negative: [],\r\n        meta: {\r\n          riskLevel: probability > 0.7 ? 'high' : probability > 0.4 ? 'moderate' : 'low',\r\n          interpretation: `${(probability * 100).toFixed(1)}% LVO probability (${classification === 1 ? 'Positive' : 'Negative'})`,\r\n        },\r\n      };\r\n\r\n      return {\r\n        probability,\r\n        drivers,\r\n        confidence: probability > 0.7 ? 0.9 : probability > 0.4 ? 0.7 : 0.5,\r\n        module: 'New LVO Model (Scientifically Calibrated)',\r\n        interpretation: `${(probability * 100).toFixed(1)}% LVO probability based on GFAP=${gfapValue} and FAST-ED=${fastEdScore}`,\r\n      };\r\n    } catch (localError) {\r\n      console.warn('‚ö†Ô∏è New LVO Model fallback failed:', localError.message);\r\n      throw new MedicalAPIError(\r\n        `LVO prediction failed: ${error.message}`,\r\n        error.status || 500,\r\n        API_URLS.LVO_PREDICTION,\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Full Stroke Prediction - Enhanced with Enterprise Patterns\r\n * @param {Object} payload - Complete patient data\r\n * @param {number} retryCount - Retry attempt counter\r\n * @returns {Promise<Object>} Complete stroke assessment\r\n */\r\nexport async function predictFullStroke(payload, retryCount = 0) {\r\n  console.log('[API] predictFullStroke called with payload:', payload);\r\n  console.log('[API] isLocalPreview():', isLocalPreview());\r\n\r\n  try {\r\n    // Get ICH prediction using enterprise client\r\n    const fullStrokeResponse = await clientHelpers.predict('full_stroke', payload);\r\n    console.log('[API] Full stroke raw response:', fullStrokeResponse);\r\n\r\n    // Extract ICH data from nested structure\r\n    const ichResult = fullStrokeResponse.ich_prediction || {};\r\n    console.log('[API] Extracted ICH data:', ichResult);\r\n\r\n    // Get LVO prediction using enhanced LVO function\r\n    let lvoResult = null;\r\n    try {\r\n      console.log('üîÑ Using dedicated LVO prediction (cloud function + fallback)');\r\n      lvoResult = await predictLVO(payload);\r\n      console.log('‚úÖ LVO prediction successful via dedicated function');\r\n    } catch (lvoError) {\r\n      console.warn('‚ö†Ô∏è Dedicated LVO prediction failed:', lvoError);\r\n\r\n      // Fallback: try to extract LVO from full stroke response if available\r\n      if (ichResult.lvo_prediction) {\r\n        lvoResult = {\r\n          probability: ichResult.lvo_prediction.probability || 0,\r\n          drivers: ichResult.lvo_prediction.drivers || null,\r\n          confidence: ichResult.lvo_prediction.confidence || 0.8,\r\n          module: 'Full Stroke (API Fallback)',\r\n        };\r\n      } else {\r\n        // Final fallback to local LVO model\r\n        lvoResult = await predictLVO(payload);\r\n      }\r\n    }\r\n\r\n    return {\r\n      ich: {\r\n        probability: ichResult.probability,\r\n        drivers: ichResult.drivers ? formatDriversFromDict(ichResult.drivers, 'ICH') : ichResult.drivers,\r\n        confidence: ichResult.confidence,\r\n        module: ichResult.module,\r\n      },\r\n      lvo: lvoResult,\r\n    };\r\n  } catch (error) {\r\n    console.error('Full Stroke prediction failed:', error);\r\n\r\n    if (error.status === 408 && retryCount < 1) {\r\n      console.log('‚è±Ô∏è Retrying Full Stroke API (cold start detected)...');\r\n      return predictFullStroke(payload, retryCount + 1);\r\n    }\r\n\r\n    // Use local preview fallback for development\r\n    if (isLocalPreview()) {\r\n      const mockData = DEV_CONFIG.mockApiResponses.full_stroke;\r\n      const ichPrediction = mockData.ich_prediction || {};\r\n      const lvoPrediction = mockData.lvo_prediction || {};\r\n\r\n      return {\r\n        ich: {\r\n          probability: clientHelpers.safeParseFloat(ichPrediction.probability, 0),\r\n          drivers: ichPrediction.drivers || null,\r\n          confidence: clientHelpers.safeParseFloat(ichPrediction.confidence, 0.85),\r\n          module: 'Full Stroke (Mock)',\r\n        },\r\n        lvo: {\r\n          probability: clientHelpers.safeParseFloat(lvoPrediction.probability, 0),\r\n          drivers: lvoPrediction.drivers || null,\r\n          confidence: clientHelpers.safeParseFloat(lvoPrediction.confidence, 0.85),\r\n          module: 'Full Stroke (Mock)',\r\n        },\r\n      };\r\n    }\r\n\r\n    throw new MedicalAPIError(\r\n      `Failed to get stroke predictions: ${error.message}`,\r\n      error.status,\r\n      API_URLS.FULL_STROKE,\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Helper function to check if running in local preview\r\n * @returns {boolean} True if local preview environment\r\n */\r\nfunction isLocalPreview() {\r\n  return ['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname);\r\n}\r\n\r\n/**\r\n * Re-export utility functions for backward compatibility\r\n */\r\nexport const normalizeBooleans = (payload) => clientHelpers.normalizeBooleans(payload);\r\nexport const safeParseFloat = (value, defaultValue) => clientHelpers.safeParseFloat(value, defaultValue);\r\n\r\n/**\r\n * Get API client statistics for monitoring\r\n * @returns {Object} Client statistics\r\n */\r\nexport function getClientStats() {\r\n  return clientHelpers.getRequestStats();\r\n}\r\n\r\n/**\r\n * Cancel all active API requests\r\n */\r\nexport function cancelAllRequests() {\r\n  clientHelpers.cancelAllRequests();\r\n}\r\n","/**\r\n * ICH Volume Calculation and Clinical Assessment\r\n * Based on validated log-log regression model (R¬≤ = 0.476)\r\n * Formula: log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)\r\n *\r\n * @typedef {import('../types/medical-types.js').ICHVolumeResult} ICHVolumeResult\r\n * @typedef {import('../types/medical-types.js').ValidationResult} ValidationResult\r\n */\r\n\r\n// Bulletproof error handling utilities\r\nimport {\r\n  safeAsync,\r\n  safeMedicalCalculation,\r\n  MedicalError,\r\n  ERROR_CATEGORIES,\r\n  ERROR_SEVERITY,\r\n  MEDICAL_ERROR_CODES,\r\n  validateMedicalInputs,\r\n} from '../utils/error-handler.js';\r\n\r\n// Type safety utilities\r\nimport { TypeChecker, MEDICAL_CONSTANTS } from '../types/medical-types.js';\r\n\r\n// Professional logging\r\nimport { medicalLogger, LOG_CATEGORIES } from '../utils/medical-logger.js';\r\n\r\n// Volume-based risk thresholds with clinical significance\r\nexport const VOLUME_THRESHOLDS = {\r\n  low: {\r\n    max: 10, color: '#dc2626', label: 'Small', severity: 'low',\r\n  },\r\n  moderate: {\r\n    min: 10, max: 20, color: '#dc2626', label: 'Moderate', severity: 'moderate',\r\n  },\r\n  high: {\r\n    min: 20, max: 30, color: '#dc2626', label: 'Large', severity: 'high',\r\n  },\r\n  critical: {\r\n    min: 30, color: '#dc2626', label: 'Critical', severity: 'critical',\r\n  },\r\n};\r\n\r\n// 30-day mortality rates by hemorrhage volume (based on clinical literature)\r\n// Calibrated to Broderick et al. (1993) landmark study:\r\n// - 30ml = 19% mortality\r\n// - 60ml = 91% mortality\r\n// With correlation strengths from observational data\r\n// Reference thresholds for documentation purposes:\r\nexport const MORTALITY_BY_VOLUME = {\r\n  '<10ml': '5-10%', // Minor hemorrhage\r\n  '10-30ml': '10-19%', // Small (Broderick: 30ml=19%)\r\n  '30-50ml': '19-44%', // Moderate (interpolated)\r\n  '50-60ml': '44-91%', // Large (Broderick: 60ml=91%)\r\n  '‚â•60ml': '91-100%', // Massive (Broderick: >60ml=91-100%)\r\n};\r\n\r\n/**\r\n * Calculate ICH volume from GFAP biomarker value with bulletproof error handling\r\n * @param {number} gfapValue - GFAP value in pg/ml (29-10,001)\r\n * @returns {Promise<ICHVolumeResult>} Volume calculation results with type safety\r\n */\r\nexport async function calculateICHVolume(gfapValue) {\r\n  return safeMedicalCalculation(\r\n    async (inputs) => {\r\n      const { gfap } = inputs;\r\n\r\n      medicalLogger.info('ICH volume calculation started', {\r\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\r\n        gfapValue: gfap,\r\n        operation: 'ich_volume_calculation',\r\n      });\r\n\r\n      // Type safety validation first\r\n      TypeChecker.ensureType(gfap, 'number', 'GFAP value');\r\n      TypeChecker.ensureRange(gfap, MEDICAL_CONSTANTS.GFAP_RANGE, 'GFAP value');\r\n\r\n      // Validate medical input\r\n      const validation = validateMedicalInputs(\r\n        { gfap },\r\n        {\r\n          gfap: {\r\n            required: true,\r\n            type: 'number',\r\n            min: 0,\r\n            max: 10001,\r\n            warningMin: 29,\r\n            warningMax: 10000,\r\n          },\r\n        },\r\n      );\r\n\r\n      if (!validation.isValid) {\r\n        throw new MedicalError(\r\n          validation.errors[0]?.message || 'Invalid GFAP value',\r\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n          ERROR_CATEGORIES.VALIDATION,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ validationErrors: validation.errors, gfapValue: gfap });\r\n      }\r\n\r\n      // Handle edge cases\r\n      if (!gfap || gfap <= 0) {\r\n        return {\r\n          volume: 0,\r\n          volumeRange: { min: 0, max: 0 },\r\n          riskLevel: 'low',\r\n          mortalityRate: '~0%',\r\n          isValid: true,\r\n          calculation: 'No hemorrhage detected',\r\n          warnings: [],\r\n        };\r\n      }\r\n\r\n      // Cap extremely high GFAP values\r\n      const cappedGfap = Math.min(gfap, 10000);\r\n      const warnings = [];\r\n      if (gfap > 10000) {\r\n        warnings.push(`GFAP value ${gfap} exceeds maximum calculation range and was capped at 10,000 pg/ml`);\r\n      }\r\n\r\n      // Values above 10,000 pg/ml are capped for calculation stability\r\n      if (cappedGfap !== gfap) {\r\n        warnings.push('GFAP value was adjusted for calculation stability');\r\n      }\r\n\r\n      // Apply log-log regression formula with error checking\r\n      if (cappedGfap <= 0) {\r\n        throw new MedicalError(\r\n          'GFAP value must be positive for volume calculation',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ gfapValue: cappedGfap });\r\n      }\r\n\r\n      const logGfap = Math.log10(cappedGfap);\r\n      if (!isFinite(logGfap)) {\r\n        throw new MedicalError(\r\n          'Invalid logarithm calculation for GFAP value',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ gfapValue: cappedGfap, logValue: logGfap });\r\n      }\r\n\r\n      const logVolume = 0.0192 + 0.4533 * logGfap;\r\n      if (!isFinite(logVolume)) {\r\n        throw new MedicalError(\r\n          'Invalid volume calculation result',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ logGfap, logVolume });\r\n      }\r\n\r\n      const calculatedVolume = 10 ** logVolume;\r\n      if (!isFinite(calculatedVolume) || calculatedVolume < 0) {\r\n        throw new MedicalError(\r\n          'Calculated volume is invalid',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ logVolume, calculatedVolume });\r\n      }\r\n\r\n      // Calculate confidence range (¬±30%)\r\n      const volumeRange = {\r\n        min: calculatedVolume * 0.7,\r\n        max: calculatedVolume * 1.3,\r\n      };\r\n\r\n      // Determine risk level based on volume\r\n      const riskLevel = getVolumeRiskLevel(calculatedVolume);\r\n\r\n      // Get mortality rate\r\n      const mortalityRate = getMortalityRate(calculatedVolume);\r\n\r\n      // Format volume for display\r\n      const displayVolume = calculatedVolume < 1 ? '<1' : calculatedVolume.toFixed(1);\r\n\r\n      // Safety check for extreme values\r\n      if (calculatedVolume > 200) {\r\n        warnings.push('Calculated volume is extremely high - please verify GFAP measurement');\r\n      }\r\n\r\n      /** @type {ICHVolumeResult} */\r\n      const result = {\r\n        volume: calculatedVolume,\r\n        confidence: 0.476, // R¬≤ of the regression model\r\n        volumeCategory: getVolumeCategory(calculatedVolume),\r\n        timestamp: new Date().toISOString(),\r\n        // Legacy properties for backward compatibility\r\n        displayVolume,\r\n        volumeRange: {\r\n          min: volumeRange.min.toFixed(1),\r\n          max: volumeRange.max.toFixed(1),\r\n        },\r\n        riskLevel,\r\n        mortalityRate,\r\n        isValid: true,\r\n        calculation: `Based on GFAP ${gfap} pg/ml`,\r\n        threshold: calculatedVolume >= 30 ? 'SURGICAL' : calculatedVolume >= 20 ? 'HIGH_RISK' : 'MANAGEABLE',\r\n        warnings,\r\n        metadata: {\r\n          originalGfap: gfap,\r\n          cappedGfap,\r\n          calculationTimestamp: new Date().toISOString(),\r\n        },\r\n      };\r\n\r\n      // Validate final result\r\n      if (typeof result.volume !== 'number' || !isFinite(result.volume)) {\r\n        medicalLogger.error('ICH volume calculation result validation failed', {\r\n          category: LOG_CATEGORIES.MEDICAL_CALCULATION,\r\n          gfapValue: gfap,\r\n          resultVolume: result.volume,\r\n          resultType: typeof result.volume,\r\n        });\r\n        throw new MedicalError(\r\n          'Final volume calculation result is invalid',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.CRITICAL,\r\n        ).withContext({ result });\r\n      }\r\n\r\n      medicalLogger.info('ICH volume calculation completed successfully', {\r\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\r\n        gfapValue: gfap,\r\n        calculatedVolume: result.volume,\r\n        volumeCategory: result.volumeCategory,\r\n        riskLevel: result.riskLevel,\r\n        confidence: result.confidence,\r\n      });\r\n\r\n      return result;\r\n    },\r\n    { gfap: gfapValue },\r\n    {\r\n      timeout: 5000,\r\n      fallback: (error) => ({\r\n        volume: 0,\r\n        volumeRange: { min: 0, max: 0 },\r\n        riskLevel: 'low',\r\n        mortalityRate: 'Calculation unavailable',\r\n        isValid: false,\r\n        calculation: 'Calculation error - using fallback',\r\n        error: error.message,\r\n        fallbackUsed: true,\r\n        warnings: ['Volume calculation failed - fallback values used'],\r\n      }),\r\n      context: {\r\n        operation: 'ich_volume_calculation',\r\n        gfapValue,\r\n        formula: 'log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)',\r\n      },\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * Fast synchronous volume estimate for UI rendering\r\n * Mirrors the main formula without async/error wrappers.\r\n * @param {number} gfap\r\n * @returns {number} estimated volume in ml (>= 0)\r\n */\r\nexport function estimateVolumeFromGFAP(gfap) {\r\n  try {\r\n    const v = Math.max(0, 10 ** (0.0192 + 0.4533 * Math.log10(Math.max(1, Math.min(gfap, 10000)))));\r\n    return Number.isFinite(v) ? v : 0;\r\n  } catch {\r\n    return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Estimate mortality band from volume (synchronous, display-only)\r\n * @param {number} volume\r\n * @returns {string}\r\n */\r\nexport function estimateMortalityFromVolume(volume) {\r\n  if (!Number.isFinite(volume) || volume <= 0) {\r\n    return '5-10%';\r\n  }\r\n  if (volume >= 60) {\r\n    return '91-100%';\r\n  }\r\n  if (volume >= 50) {\r\n    return '44-91%';\r\n  }\r\n  if (volume >= 30) {\r\n    return '19-44%';\r\n  }\r\n  if (volume >= 10) {\r\n    return '10-19%';\r\n  }\r\n  return '5-10%';\r\n}\r\n\r\n/**\r\n * Determine risk level based on calculated volume with safety checks\r\n * @param {number} volume - Calculated volume in ml\r\n * @returns {string} Risk level key\r\n */\r\nfunction getVolumeRiskLevel(volume) {\r\n  try {\r\n    // Input validation\r\n    if (typeof volume !== 'number' || !isFinite(volume)) {\r\n      throw new MedicalError(\r\n        'Invalid volume for risk level calculation',\r\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n        ERROR_CATEGORIES.MEDICAL,\r\n        ERROR_SEVERITY.MEDIUM,\r\n      ).withContext({ volume, type: typeof volume });\r\n    }\r\n\r\n    if (volume < 0) {\r\n      throw new MedicalError(\r\n        'Volume cannot be negative',\r\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n        ERROR_CATEGORIES.MEDICAL,\r\n        ERROR_SEVERITY.MEDIUM,\r\n      ).withContext({ volume });\r\n    }\r\n\r\n    if (volume >= VOLUME_THRESHOLDS.critical.min) {\r\n      return 'critical';\r\n    }\r\n    if (volume >= VOLUME_THRESHOLDS.high.min) {\r\n      return 'high';\r\n    }\r\n    if (volume >= VOLUME_THRESHOLDS.moderate.min) {\r\n      return 'moderate';\r\n    }\r\n    return 'low';\r\n  } catch (error) {\r\n    // Fallback to 'low' for safety\r\n    console.warn('Risk level calculation failed, defaulting to low:', error.message);\r\n    return 'low';\r\n  }\r\n}\r\n\r\n/**\r\n * Get mortality rate based on volume with improved interpolation and safety checks\r\n * Calibrated to match clinical studies (Broderick 1993: 30ml=19%, 60ml=91%)\r\n * @param {number} volume - Volume in ml\r\n * @returns {string} Mortality rate string with citation\r\n */\r\nfunction getMortalityRate(volume) {\r\n  try {\r\n    // Input validation\r\n    if (typeof volume !== 'number' || !isFinite(volume)) {\r\n      throw new MedicalError(\r\n        'Invalid volume for mortality rate calculation',\r\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n        ERROR_CATEGORIES.MEDICAL,\r\n        ERROR_SEVERITY.MEDIUM,\r\n      ).withContext({ volume, type: typeof volume });\r\n    }\r\n\r\n    if (volume < 0) {\r\n      return 'Invalid volume';\r\n    }\r\n\r\n    // For very small hemorrhages\r\n    if (volume < 10) {\r\n      return '5-10%‚Å¥';\r\n    }\r\n\r\n    // For small hemorrhages (10-30ml)\r\n    // Broderick: 30ml = 19% mortality\r\n    if (volume < 30) {\r\n      // Linear interpolation: 10ml=10%, 30ml=19%\r\n      const rate = Math.round(10 + (volume - 10) * (19 - 10) / (30 - 10));\r\n      // Validate interpolated rate\r\n      if (rate < 0 || rate > 100) {\r\n        throw new MedicalError(\r\n          'Calculated mortality rate out of valid range',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ volume, rate });\r\n      }\r\n      return `${rate}%‚Å¥`;\r\n    }\r\n\r\n    // For moderate hemorrhages (30-50ml)\r\n    // Interpolating from Broderick 30ml=19% to 50ml‚âà44%\r\n    if (volume < 50) {\r\n      // Linear interpolation: 30ml=19%, 50ml=44%\r\n      const rate = Math.round(19 + (volume - 30) * (44 - 19) / (50 - 30));\r\n      if (rate < 0 || rate > 100) {\r\n        throw new MedicalError(\r\n          'Calculated mortality rate out of valid range',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ volume, rate });\r\n      }\r\n      return `${rate}%¬≥`;\r\n    }\r\n\r\n    // For large hemorrhages (50-60ml)\r\n    // Broderick: 60ml = 91% mortality\r\n    if (volume < 60) {\r\n      // Steeper increase: 50ml=44%, 60ml=91%\r\n      const rate = Math.round(44 + (volume - 50) * (91 - 44) / (60 - 50));\r\n      if (rate < 0 || rate > 100) {\r\n        throw new MedicalError(\r\n          'Calculated mortality rate out of valid range',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ volume, rate });\r\n      }\r\n      return `${rate}%¬≤`;\r\n    }\r\n\r\n    // For massive hemorrhages (‚â•60ml)\r\n    // Broderick: >60ml = 91-100%\r\n    if (volume < 80) {\r\n      // 60ml=91%, 80ml=96%\r\n      const rate = Math.round(91 + (volume - 60) * (96 - 91) / (80 - 60));\r\n      if (rate < 0 || rate > 100) {\r\n        throw new MedicalError(\r\n          'Calculated mortality rate out of valid range',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.HIGH,\r\n        ).withContext({ volume, rate });\r\n      }\r\n      return `${rate}%¬π`;\r\n    }\r\n\r\n    // For extreme cases (‚â•80ml)\r\n    return '96-100%¬π';\r\n  } catch (error) {\r\n    // Fallback for safety\r\n    console.warn('Mortality rate calculation failed:', error.message);\r\n    return 'Rate unavailable';\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate hemorrhage size percentage for visualization with safety checks\r\n * Based on brain area scaling: 30ml = ~40% of brain area, 100ml = ~70%\r\n * @param {number} volume - Volume in ml\r\n * @returns {Promise<number>} Percentage of brain area (0-70)\r\n */\r\nexport async function calculateHemorrhageSizePercent(volume) {\r\n  return safeAsync(\r\n    async () => {\r\n      // Input validation\r\n      if (typeof volume !== 'number' || !isFinite(volume)) {\r\n        throw new MedicalError(\r\n          'Invalid volume for size percentage calculation',\r\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n          ERROR_CATEGORIES.VALIDATION,\r\n          ERROR_SEVERITY.MEDIUM,\r\n        ).withContext({ volume, type: typeof volume });\r\n      }\r\n\r\n      if (volume < 0) {\r\n        throw new MedicalError(\r\n          'Volume cannot be negative for visualization',\r\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\r\n          ERROR_CATEGORIES.VALIDATION,\r\n          ERROR_SEVERITY.MEDIUM,\r\n        ).withContext({ volume });\r\n      }\r\n\r\n      if (volume <= 0) {\r\n        return 0;\r\n      }\r\n      if (volume >= 100) {\r\n        return 70;\r\n      } // Maximum 70% of brain area\r\n\r\n      // Non-linear scaling for realistic appearance\r\n      // 30ml = 40%, 100ml = 70%\r\n      const sqrtValue = Math.sqrt(volume / 30);\r\n      if (!isFinite(sqrtValue)) {\r\n        throw new MedicalError(\r\n          'Invalid square root calculation for visualization',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.MEDIUM,\r\n        ).withContext({ volume, sqrtValue });\r\n      }\r\n\r\n      const basePercent = sqrtValue * 40;\r\n      const result = Math.min(basePercent, 70);\r\n\r\n      // Final validation\r\n      if (!isFinite(result) || result < 0 || result > 100) {\r\n        throw new MedicalError(\r\n          'Calculated percentage out of valid range',\r\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\r\n          ERROR_CATEGORIES.MEDICAL,\r\n          ERROR_SEVERITY.MEDIUM,\r\n        ).withContext({ volume, basePercent, result });\r\n      }\r\n\r\n      return result;\r\n    },\r\n    {\r\n      category: ERROR_CATEGORIES.MEDICAL,\r\n      severity: ERROR_SEVERITY.LOW,\r\n      timeout: 1000,\r\n      fallback: () => {\r\n        // Safe fallback based on simple linear scaling\r\n        if (volume <= 0) {\r\n          return 0;\r\n        }\r\n        if (volume >= 100) {\r\n          return 70;\r\n        }\r\n        return Math.min((volume / 100) * 70, 70);\r\n      },\r\n      context: {\r\n        operation: 'hemorrhage_size_calculation',\r\n        volume,\r\n      },\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * Get color for volume visualization\r\n * @param {number} volume - Volume in ml\r\n * @returns {string} CSS color value\r\n */\r\nexport function getVolumeColor(volume) {\r\n  const riskLevel = getVolumeRiskLevel(volume);\r\n  return VOLUME_THRESHOLDS[riskLevel].color;\r\n}\r\n\r\n/**\r\n * Test function for validation with comprehensive error handling\r\n * Tests the calculator with known GFAP values\r\n */\r\nexport async function testVolumeCalculator() {\r\n  return safeAsync(\r\n    async () => {\r\n      const testCases = [\r\n        { gfap: 100, expectedVolume: '~5ml' },\r\n        { gfap: 500, expectedVolume: '~15ml' },\r\n        { gfap: 1000, expectedVolume: '~21ml' },\r\n        { gfap: 1500, expectedVolume: '~28ml' },\r\n        { gfap: 3000, expectedVolume: '~50ml' },\r\n        { gfap: 5000, expectedVolume: '~72ml' },\r\n      ];\r\n\r\n      // ICH Volume Calculator Test Results\r\n      const results = await Promise.allSettled(\r\n        testCases.map(async (test) => {\r\n          try {\r\n            const result = await calculateICHVolume(test.gfap);\r\n            return {\r\n              gfap: test.gfap, result, expected: test.expectedVolume, success: true,\r\n            };\r\n          } catch (error) {\r\n            return {\r\n              gfap: test.gfap,\r\n              result: null,\r\n              expected: test.expectedVolume,\r\n              success: false,\r\n              error: error.message,\r\n            };\r\n          }\r\n        }),\r\n      );\r\n\r\n      // Process results and handle any failures\r\n      const processedResults = results.map((result, index) => {\r\n        if (result.status === 'fulfilled') {\r\n          return result.value;\r\n        }\r\n        return {\r\n          gfap: testCases[index].gfap,\r\n          result: null,\r\n          expected: testCases[index].expectedVolume,\r\n          success: false,\r\n          error: result.reason?.message || 'Test failed',\r\n        };\r\n      });\r\n\r\n      const successfulTests = processedResults.filter((r) => r.success).length;\r\n      const totalTests = testCases.length;\r\n\r\n      return {\r\n        results: processedResults,\r\n        summary: {\r\n          total: totalTests,\r\n          successful: successfulTests,\r\n          failed: totalTests - successfulTests,\r\n          successRate: `${Math.round((successfulTests / totalTests) * 100)}%`,\r\n        },\r\n        timestamp: new Date().toISOString(),\r\n      };\r\n    },\r\n    {\r\n      category: ERROR_CATEGORIES.MEDICAL,\r\n      severity: ERROR_SEVERITY.LOW,\r\n      timeout: 10000,\r\n      fallback: (error) => ({\r\n        results: [],\r\n        summary: {\r\n          total: 0,\r\n          successful: 0,\r\n          failed: 0,\r\n          successRate: '0%',\r\n        },\r\n        error: error.message,\r\n        timestamp: new Date().toISOString(),\r\n      }),\r\n      context: {\r\n        operation: 'volume_calculator_test',\r\n      },\r\n    },\r\n  );\r\n}\r\n\r\n/**\r\n * Get volume category according to medical type definitions\r\n * @param {number} volume - Volume in ml\r\n * @returns {'small'|'moderate'|'large'|'massive'} Volume category\r\n */\r\nfunction getVolumeCategory(volume) {\r\n  try {\r\n    // Type safety validation\r\n    TypeChecker.ensureType(volume, 'number', 'volume for categorization');\r\n\r\n    if (volume < 0) {\r\n      throw new TypeError('Volume cannot be negative for categorization');\r\n    }\r\n\r\n    const thresholds = MEDICAL_CONSTANTS.VOLUME_THRESHOLDS;\r\n\r\n    if (volume < thresholds.SMALL) {\r\n      return 'small';\r\n    }\r\n    if (volume < thresholds.MODERATE) {\r\n      return 'moderate';\r\n    }\r\n    if (volume < thresholds.LARGE) {\r\n      return 'large';\r\n    }\r\n    return 'massive';\r\n  } catch (error) {\r\n    // Fallback to 'small' for safety\r\n    return 'small';\r\n  }\r\n}\r\n\r\n/**\r\n * Format volume for display with appropriate precision\r\n * @param {number} volume - Volume in ml\r\n * @returns {string} Formatted volume string\r\n */\r\nexport function formatVolumeDisplay(volume) {\r\n  if (volume < 1) {\r\n    return '<1 ml';\r\n  }\r\n  if (volume < 10) {\r\n    return `${volume.toFixed(1)} ml`;\r\n  }\r\n  return `${Math.round(volume)} ml`;\r\n}\r\n"],"names":["APIError","message","status","url","MedicalAPIError","formatDriversFromDict","drivers","predictionType","positive","negative","label","weight","a","b","clientHelpers","value","defaultValue","parsed","payload","normalized","key","endpoint","endpointType","controller","timeout","timeoutId","normalizedPayload","response","errorText","result","error","moduleType","API_URLS","warmUpFunctions","warmUpPromises","index","resolve","predictComaIch","apiError","predictLimitedIch","predictLVO","retryCount","gfapValue","fastEdScore","probability","lvoProbability","classification","lvoClass","localError","predictFullStroke","isLocalPreview","fullStrokeResponse","ichResult","lvoResult","lvoError","mockData","DEV_CONFIG","ichPrediction","lvoPrediction","estimateVolumeFromGFAP","gfap","v","e","estimateMortalityFromVolume","volume","formatVolumeDisplay"],"mappings":"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"}