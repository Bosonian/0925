{"version":3,"file":"prediction-strategy-gbd4GMNt.js","sources":["../../src/patterns/prediction-strategy.js"],"sourcesContent":["/**\n * Strategy Pattern for Medical Prediction Algorithms\n * iGFAP Stroke Triage Assistant - Enterprise Architecture\n *\n * Provides pluggable prediction strategies for different medical scenarios\n */\n\nimport { predictComaIch, predictLimitedIch, predictFullStroke } from \"../api/client.js\";\n\nimport { medicalEventObserver, MEDICAL_EVENTS } from \"./observer.js\";\n\n/**\n * Abstract base strategy for medical predictions\n */\nclass PredictionStrategy {\n  constructor(name, description) {\n    this.name = name;\n    this.description = description;\n    this.requiredFields = [];\n    this.optionalFields = [];\n  }\n\n  /**\n   * Validate input data before prediction\n   * @param {Object} inputData - Input data for prediction\n   * @returns {Object} Validation result\n   */\n  validateInput(inputData) {\n    const errors = [];\n    const missingFields = [];\n\n    // Check required fields\n    this.requiredFields.forEach((field) => {\n      if (!(field in inputData) || inputData[field] === null || inputData[field] === undefined) {\n        missingFields.push(field);\n      }\n    });\n\n    if (missingFields.length > 0) {\n      errors.push(`Missing required fields: ${missingFields.join(\", \")}`);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      missingFields,\n    };\n  }\n\n  /**\n   * Preprocess input data for the specific strategy\n   * @param {Object} inputData - Raw input data\n   * @returns {Object} Processed input data\n   */\n  preprocessInput(inputData) {\n    // Default implementation - can be overridden by specific strategies\n    return { ...inputData };\n  }\n\n  /**\n   * Execute the prediction strategy\n   * @param {Object} inputData - Input data for prediction\n   * @returns {Promise<Object>} Prediction result\n   */\n  async predict(inputData) {\n    throw new Error(\"predict() method must be implemented by concrete strategy\");\n  }\n\n  /**\n   * Postprocess prediction results\n   * @param {Object} rawResult - Raw prediction result\n   * @param {Object} inputData - Original input data\n   * @returns {Object} Processed result\n   */\n  postprocessResult(rawResult, inputData) {\n    return {\n      ...rawResult,\n      strategy: this.name,\n      timestamp: new Date().toISOString(),\n      inputSummary: this.createInputSummary(inputData),\n    };\n  }\n\n  /**\n   * Create a summary of input data for audit trail\n   * @param {Object} inputData - Input data\n   * @returns {Object} Input summary (sanitized)\n   */\n  createInputSummary(inputData) {\n    const summary = {};\n    [...this.requiredFields, ...this.optionalFields].forEach((field) => {\n      if (field in inputData) {\n        summary[field] = typeof inputData[field];\n      }\n    });\n    return summary;\n  }\n}\n\n/**\n * Strategy for coma patients (GCS < 8)\n */\nclass ComaPredictionStrategy extends PredictionStrategy {\n  constructor() {\n    super(\"COMA_ICH\", \"ICH prediction for comatose patients\");\n    this.requiredFields = [\"gfap\"];\n    this.optionalFields = [\"age\", \"symptoms_duration\"];\n  }\n\n  preprocessInput(inputData) {\n    return {\n      gfap: parseFloat(inputData.gfap),\n      patientType: \"comatose\",\n    };\n  }\n\n  async predict(inputData) {\n    const validation = this.validateInput(inputData);\n    if (!validation.isValid) {\n      throw new Error(`Validation failed: ${validation.errors.join(\", \")}`);\n    }\n\n    const processedInput = this.preprocessInput(inputData);\n\n    // Emit event for audit trail\n    medicalEventObserver.publish(MEDICAL_EVENTS.ASSESSMENT_STARTED, {\n      strategy: this.name,\n      inputFields: Object.keys(processedInput),\n    });\n\n    try {\n      const rawResult = await predictComaIch(processedInput);\n      const result = this.postprocessResult(rawResult, inputData);\n\n      // Emit completion event\n      medicalEventObserver.publish(MEDICAL_EVENTS.RESULTS_GENERATED, {\n        strategy: this.name,\n        success: true,\n        confidence: result.confidence,\n      });\n\n      return result;\n    } catch (error) {\n      medicalEventObserver.publish(MEDICAL_EVENTS.SECURITY_EVENT, {\n        type: \"prediction_error\",\n        strategy: this.name,\n        error: error.message,\n      });\n      throw error;\n    }\n  }\n}\n\n/**\n * Strategy for limited data scenarios\n */\nclass LimitedDataPredictionStrategy extends PredictionStrategy {\n  constructor() {\n    super(\"LIMITED_DATA_ICH\", \"ICH prediction with limited clinical data\");\n    this.requiredFields = [\"gfap\", \"age\", \"systolic_bp\", \"diastolic_bp\"];\n    this.optionalFields = [\"weakness_sudden\", \"speech_sudden\", \"vigilanzminderung\"];\n  }\n\n  preprocessInput(inputData) {\n    return {\n      gfap: parseFloat(inputData.gfap),\n      age: parseInt(inputData.age, 10),\n      systolic_bp: parseFloat(inputData.systolic_bp),\n      diastolic_bp: parseFloat(inputData.diastolic_bp),\n      weakness_sudden: inputData.weakness_sudden === true || inputData.weakness_sudden === \"true\",\n      speech_sudden: inputData.speech_sudden === true || inputData.speech_sudden === \"true\",\n      vigilanzminderung: inputData.vigilanzminderung === true || inputData.vigilanzminderung === \"true\",\n    };\n  }\n\n  async predict(inputData) {\n    const validation = this.validateInput(inputData);\n    if (!validation.isValid) {\n      throw new Error(`Validation failed: ${validation.errors.join(\", \")}`);\n    }\n\n    const processedInput = this.preprocessInput(inputData);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.ASSESSMENT_STARTED, {\n      strategy: this.name,\n      inputFields: Object.keys(processedInput),\n    });\n\n    try {\n      const rawResult = await predictLimitedIch(processedInput);\n      const result = this.postprocessResult(rawResult, inputData);\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.RESULTS_GENERATED, {\n        strategy: this.name,\n        success: true,\n        confidence: result.confidence,\n      });\n\n      return result;\n    } catch (error) {\n      medicalEventObserver.publish(MEDICAL_EVENTS.SECURITY_EVENT, {\n        type: \"prediction_error\",\n        strategy: this.name,\n        error: error.message,\n      });\n      throw error;\n    }\n  }\n}\n\n/**\n * Strategy for comprehensive stroke assessment\n */\nclass FullStrokePredictionStrategy extends PredictionStrategy {\n  constructor() {\n    super(\"FULL_STROKE\", \"Comprehensive stroke prediction with full clinical data\");\n    this.requiredFields = [\n      \"gfap\", \"age\", \"systolic_bp\", \"diastolic_bp\", \"fast_ed_score\",\n      \"sex\", \"facialtwitching\", \"armparese\", \"speechdeficit\", \"gaze\", \"agitation\",\n    ];\n    this.optionalFields = [\"strokeOnsetKnown\", \"medical_history\"];\n  }\n\n  preprocessInput(inputData) {\n    return {\n      gfap: parseFloat(inputData.gfap),\n      age: parseInt(inputData.age, 10),\n      systolic_bp: parseFloat(inputData.systolic_bp),\n      diastolic_bp: parseFloat(inputData.diastolic_bp),\n      fast_ed_score: parseInt(inputData.fast_ed_score, 10),\n      sex: inputData.sex === \"male\" ? 1 : 0,\n      facialtwitching: inputData.facialtwitching === true || inputData.facialtwitching === \"true\",\n      armparese: inputData.armparese === true || inputData.armparese === \"true\",\n      speechdeficit: inputData.speechdeficit === true || inputData.speechdeficit === \"true\",\n      gaze: inputData.gaze === true || inputData.gaze === \"true\",\n      agitation: inputData.agitation === true || inputData.agitation === \"true\",\n      strokeOnsetKnown: inputData.strokeOnsetKnown === true || inputData.strokeOnsetKnown === \"true\",\n    };\n  }\n\n  async predict(inputData) {\n    const validation = this.validateInput(inputData);\n    if (!validation.isValid) {\n      throw new Error(`Validation failed: ${validation.errors.join(\", \")}`);\n    }\n\n    const processedInput = this.preprocessInput(inputData);\n\n    medicalEventObserver.publish(MEDICAL_EVENTS.ASSESSMENT_STARTED, {\n      strategy: this.name,\n      inputFields: Object.keys(processedInput),\n    });\n\n    try {\n      const rawResult = await predictFullStroke(processedInput);\n      const result = this.postprocessResult(rawResult, inputData);\n\n      medicalEventObserver.publish(MEDICAL_EVENTS.RESULTS_GENERATED, {\n        strategy: this.name,\n        success: true,\n        confidence: result.confidence,\n      });\n\n      return result;\n    } catch (error) {\n      medicalEventObserver.publish(MEDICAL_EVENTS.SECURITY_EVENT, {\n        type: \"prediction_error\",\n        strategy: this.name,\n        error: error.message,\n      });\n      throw error;\n    }\n  }\n}\n\n/**\n * Context class for managing prediction strategies\n */\nexport class PredictionContext {\n  constructor() {\n    this.strategies = new Map();\n    this.currentStrategy = null;\n    this.predictionHistory = [];\n\n    // Register default strategies\n    this.registerStrategy(new ComaPredictionStrategy());\n    this.registerStrategy(new LimitedDataPredictionStrategy());\n    this.registerStrategy(new FullStrokePredictionStrategy());\n  }\n\n  /**\n   * Register a new prediction strategy\n   * @param {PredictionStrategy} strategy - Strategy to register\n   */\n  registerStrategy(strategy) {\n    if (!(strategy instanceof PredictionStrategy)) {\n      throw new Error(\"Strategy must extend PredictionStrategy\");\n    }\n    this.strategies.set(strategy.name, strategy);\n  }\n\n  /**\n   * Set the current prediction strategy\n   * @param {string} strategyName - Name of the strategy to use\n   */\n  setStrategy(strategyName) {\n    const strategy = this.strategies.get(strategyName);\n    if (!strategy) {\n      throw new Error(`Unknown strategy: ${strategyName}`);\n    }\n    this.currentStrategy = strategy;\n  }\n\n  /**\n   * Execute prediction using the current strategy\n   * @param {Object} inputData - Input data for prediction\n   * @returns {Promise<Object>} Prediction result\n   */\n  async predict(inputData) {\n    if (!this.currentStrategy) {\n      throw new Error(\"No prediction strategy selected\");\n    }\n\n    const startTime = performance.now();\n\n    try {\n      const result = await this.currentStrategy.predict(inputData);\n      const duration = performance.now() - startTime;\n\n      // Add to prediction history\n      this.predictionHistory.push({\n        strategy: this.currentStrategy.name,\n        timestamp: new Date().toISOString(),\n        duration,\n        success: true,\n      });\n\n      return result;\n    } catch (error) {\n      const duration = performance.now() - startTime;\n\n      this.predictionHistory.push({\n        strategy: this.currentStrategy.name,\n        timestamp: new Date().toISOString(),\n        duration,\n        success: false,\n        error: error.message,\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get available strategies\n   * @returns {Array} List of available strategies\n   */\n  getAvailableStrategies() {\n    return Array.from(this.strategies.keys());\n  }\n\n  /**\n   * Get strategy information\n   * @param {string} strategyName - Name of the strategy\n   * @returns {Object} Strategy information\n   */\n  getStrategyInfo(strategyName) {\n    const strategy = this.strategies.get(strategyName);\n    if (!strategy) {\n      return null;\n    }\n\n    return {\n      name: strategy.name,\n      description: strategy.description,\n      requiredFields: strategy.requiredFields,\n      optionalFields: strategy.optionalFields,\n    };\n  }\n\n  /**\n   * Get prediction history for audit\n   * @returns {Array} Prediction history\n   */\n  getPredictionHistory() {\n    return [...this.predictionHistory];\n  }\n\n  /**\n   * Clear prediction history (privacy compliance)\n   */\n  clearHistory() {\n    this.predictionHistory = [];\n  }\n}\n\n// Export singleton instance\nexport const predictionContext = new PredictionContext();\n\n// Export strategy types for external reference\nexport const PREDICTION_STRATEGIES = {\n  COMA_ICH: \"COMA_ICH\",\n  LIMITED_DATA_ICH: \"LIMITED_DATA_ICH\",\n  FULL_STROKE: \"FULL_STROKE\",\n};\n"],"names":["PredictionStrategy","name","description","inputData","errors","missingFields","field","rawResult","summary","ComaPredictionStrategy","validation","processedInput","medicalEventObserver","MEDICAL_EVENTS","predictComaIch","result","error","LimitedDataPredictionStrategy","predictLimitedIch","FullStrokePredictionStrategy","predictFullStroke","PredictionContext","strategy","strategyName","startTime","duration","predictionContext","PREDICTION_STRATEGIES"],"mappings":"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"}