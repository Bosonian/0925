{"version":3,"file":"prediction-models-DkrcyEmP.js","sources":["../../src/api/client.js","../../src/logic/ich-volume-calculator.js"],"sourcesContent":["/**\n * Medical Prediction API Client - Refactored for Enterprise Architecture\n * Eliminates code duplication using BasePredictionClient patterns\n *\n * Key improvements:\n * - Single source of truth for API logic\n * - Consistent error handling across all endpoints\n * - DRY principle enforcement\n * - Enhanced medical validation\n * - Enterprise-grade logging and monitoring\n *\n * @author iGFAP Project Team\n * @contact Deepak Bos <bosdeepak@gmail.com>\n */\n\nimport { API_URLS, APP_CONFIG, DEV_CONFIG } from \"../config.js\";\nimport { lvoProbability, lvoClass } from \"../lib/lvoModel.js\";\n\nimport {\n  extractDriversFromResponse,\n  extractProbabilityFromResponse,\n  extractConfidenceFromResponse,\n} from \"./drivers.js\";\n\n// APIError class for medical API errors\nexport class APIError extends Error {\n  constructor(message, status, url) {\n    super(message);\n    this.name = \"APIError\";\n    this.status = status;\n    this.url = url;\n  }\n}\n\n// MedicalAPIError class (same as APIError for compatibility)\nexport class MedicalAPIError extends APIError {\n  constructor(message, status, url) {\n    super(message, status, url);\n    this.name = \"MedicalAPIError\";\n  }\n}\n\n// Helper function to format drivers from flat dictionary\nfunction formatDriversFromDict(drivers, predictionType) {\n  if (!drivers || typeof drivers !== \"object\") {\n    return null;\n  }\n\n  const positive = [];\n  const negative = [];\n\n  Object.entries(drivers).forEach(([label, weight]) => {\n    if (typeof weight === \"number\") {\n      if (weight > 0) {\n        positive.push({ label, weight });\n      } else if (weight < 0) {\n        negative.push({ label, weight: Math.abs(weight) });\n      }\n    }\n  });\n\n  // Sort by weight (descending)\n  positive.sort((a, b) => b.weight - a.weight);\n  negative.sort((a, b) => b.weight - a.weight);\n\n  return {\n    kind: \"flat_dictionary\",\n    units: \"logit\",\n    positive,\n    negative,\n    meta: {},\n  };\n}\n\n// Helper functions to replace basePredictionClient functionality\nconst clientHelpers = {\n  safeParseFloat: (value, defaultValue = 0) => {\n    const parsed = parseFloat(value);\n    return isNaN(parsed) ? defaultValue : parsed;\n  },\n\n  normalizeBooleans: payload => {\n    const normalized = { ...payload };\n    Object.keys(normalized).forEach(key => {\n      if (normalized[key] === \"true\" || normalized[key] === true) {\n        normalized[key] = 1;\n      } else if (normalized[key] === \"false\" || normalized[key] === false) {\n        normalized[key] = 0;\n      }\n    });\n    return normalized;\n  },\n\n  async makeApiCall(endpoint, payload, endpointType = \"unknown\") {\n    console.log(`[API] Making ${endpointType} request to:`, endpoint);\n    console.log(\"[API] Payload:\", payload);\n\n    try {\n      const controller = new AbortController();\n      const timeout = endpoint.includes(\"full_stroke\") ? 15000 : 8000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      const normalizedPayload = this.normalizeBooleans(payload);\n\n      const response = await fetch(endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"application/json\",\n        },\n        body: JSON.stringify(normalizedPayload),\n        signal: controller.signal,\n        mode: \"cors\",\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        const errorText = await response.text().catch(() => \"Network error\");\n        throw new MedicalAPIError(\n          `API request failed: ${response.status} ${response.statusText} - ${errorText}`,\n          response.status,\n          endpoint\n        );\n      }\n\n      const result = await response.json();\n      console.log(`[API] ${endpointType} response:`, result);\n      console.log(`[API] ${endpointType} response keys:`, Object.keys(result));\n      console.log(`[API] ${endpointType} first key:`, Object.keys(result)[0]);\n      console.log(`[API] ${endpointType} first value:`, result[Object.keys(result)[0]]);\n      console.log(`[API] ${endpointType} probability:`, result.probability);\n      console.log(`[API] ${endpointType} ich_probability:`, result.ich_probability);\n\n      // Normalize response: some APIs return \"ich_probability\" instead of \"probability\"\n      if (!result.probability && result.ich_probability !== undefined) {\n        result.probability = result.ich_probability;\n        console.log(\n          `[API] ${endpointType} normalized probability from ich_probability:`,\n          result.probability\n        );\n      }\n\n      return result;\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        console.warn(`[API] ${endpointType} request timeout`);\n        throw new MedicalAPIError(`Request timeout after ${timeout / 1000}s`, 408, endpoint);\n      }\n\n      if (error instanceof MedicalAPIError) {\n        throw error;\n      }\n\n      console.error(`[API] ${endpointType} request failed:`, error);\n      throw new MedicalAPIError(`Network error: ${error.message}`, 0, endpoint);\n    }\n  },\n\n  getRequestStats: () => ({ requests: 0, errors: 0, avgResponseTime: 0 }),\n  cancelAllRequests: () => console.log(\"Cancel requests - not implemented\"),\n\n  async predict(moduleType, payload) {\n    const endpointMap = {\n      coma_ich: API_URLS.COMA_ICH,\n      limited_ich: API_URLS.LDM_ICH,\n      full_stroke: API_URLS.FULL_STROKE,\n      lvo: API_URLS.LVO_PREDICTION,\n    };\n\n    const endpoint = endpointMap[moduleType];\n    if (!endpoint) {\n      throw new MedicalAPIError(`Unknown module type: ${moduleType}`, 400, \"unknown\");\n    }\n\n    return await this.makeApiCall(endpoint, payload, moduleType);\n  },\n};\n\n/**\n * Warm up Google Cloud Functions on app load\n * Optimized for production reliability\n */\nexport async function warmUpFunctions() {\n  console.log(\"Warming up Cloud Functions...\");\n\n  const prioritizedUrls = [\n    API_URLS.FULL_STROKE, // Warm this first - most complex\n    API_URLS.LVO_PREDICTION, // New LVO endpoint\n    API_URLS.COMA_ICH,\n    API_URLS.LDM_ICH,\n    API_URLS.AUTHENTICATE,\n  ];\n\n  const warmUpPromises = prioritizedUrls.map(async (url, index) => {\n    await new Promise(resolve => setTimeout(resolve, index * 200));\n\n    try {\n      const controller = new AbortController();\n      const timeout = url.includes(\"full_stroke\") ? 8000 : 3000;\n      const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n      await fetch(url, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({}),\n        signal: controller.signal,\n        mode: \"cors\",\n      });\n\n      clearTimeout(timeoutId);\n      console.log(`‚úì Warmed up: ${url.split(\"/\").pop()}`);\n    } catch (error) {\n      console.log(`‚úì Warm-up attempt for ${url.split(\"/\").pop()} completed`);\n    }\n  });\n\n  Promise.all(warmUpPromises)\n    .then(() => {\n      console.log(\"‚úÖ Cloud Functions warm-up complete\");\n    })\n    .catch(() => {\n      // Silently handle errors\n    });\n}\n\n/**\n * COMA ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for coma module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictComaIch(payload) {\n  try {\n    return await clientHelpers.predict(\"coma_ich\", payload);\n  } catch (error) {\n    // Transform MedicalAPIError back to APIError for backward compatibility\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = \"APIError\";\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * Limited Data ICH Prediction - Refactored to use BasePredictionClient\n * @param {Object} payload - Patient data for limited data module\n * @returns {Promise<Object>} ICH prediction result\n */\nexport async function predictLimitedIch(payload) {\n  try {\n    return await clientHelpers.predict(\"limited_ich\", payload);\n  } catch (error) {\n    if (error instanceof MedicalAPIError) {\n      const apiError = new Error(error.message);\n      apiError.name = \"APIError\";\n      apiError.status = error.status;\n      apiError.url = error.url;\n      throw apiError;\n    }\n    throw error;\n  }\n}\n\n/**\n * LVO Prediction with Enhanced Fallback Logic\n * @param {Object} payload - Patient data for LVO assessment\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} LVO prediction result\n */\nexport async function predictLVO(payload, retryCount = 0) {\n  console.log(\"[API] predictLVO called with payload:\", payload);\n\n  if (!payload.gfap_value || !payload.fast_ed_score) {\n    throw new MedicalAPIError(\n      \"Missing required parameters: gfap_value and fast_ed_score\",\n      400,\n      API_URLS.LVO_PREDICTION\n    );\n  }\n\n  console.log(\"[API] LVO payload preparation...\");\n\n  try {\n    // Try enterprise client first\n    console.log(\"üå©Ô∏è Using LVO Cloud Function (primary)\");\n    const result = await clientHelpers.predict(\"lvo\", payload);\n    console.log(\"[API] LVO Cloud Function response:\", result);\n    return result;\n  } catch (error) {\n    console.warn(\"‚ö†Ô∏è LVO Cloud Function failed, falling back to local model:\", error.message);\n    console.log(\"üè† Using New LVO Model (fallback)\");\n\n    try {\n      const gfapValue = parseFloat(payload.gfap_value);\n      const fastEdScore = parseInt(payload.fast_ed_score);\n\n      if (isNaN(gfapValue) || isNaN(fastEdScore)) {\n        throw new Error(\"Invalid GFAP or FAST-ED values\");\n      }\n\n      const probability = lvoProbability(gfapValue, fastEdScore);\n      const classification = lvoClass(gfapValue, fastEdScore);\n\n      const drivers = {\n        kind: \"new_model_fallback\",\n        units: \"normalized_contribution\",\n        positive: [\n          { label: \"GFAP Biomarker\", weight: gfapValue > 100 ? 0.6 : 0.3 },\n          { label: \"FAST-ED Score\", weight: fastEdScore * 0.1 },\n        ].sort((a, b) => Math.abs(b.weight) - Math.abs(a.weight)),\n        negative: [],\n        meta: {\n          riskLevel: probability > 0.7 ? \"high\" : probability > 0.4 ? \"moderate\" : \"low\",\n          interpretation: `${(probability * 100).toFixed(1)}% LVO probability (${classification === 1 ? \"Positive\" : \"Negative\"})`,\n        },\n      };\n\n      return {\n        probability,\n        drivers,\n        confidence: probability > 0.7 ? 0.9 : probability > 0.4 ? 0.7 : 0.5,\n        module: \"New LVO Model (Scientifically Calibrated)\",\n        interpretation: `${(probability * 100).toFixed(1)}% LVO probability based on GFAP=${gfapValue} and FAST-ED=${fastEdScore}`,\n      };\n    } catch (localError) {\n      console.warn(\"‚ö†Ô∏è New LVO Model fallback failed:\", localError.message);\n      throw new MedicalAPIError(\n        `LVO prediction failed: ${error.message}`,\n        error.status || 500,\n        API_URLS.LVO_PREDICTION\n      );\n    }\n  }\n}\n\n/**\n * Full Stroke Prediction - Enhanced with Enterprise Patterns\n * @param {Object} payload - Complete patient data\n * @param {number} retryCount - Retry attempt counter\n * @returns {Promise<Object>} Complete stroke assessment\n */\nexport async function predictFullStroke(payload, retryCount = 0) {\n  console.log(\"[API] predictFullStroke called with payload:\", payload);\n  console.log(\"[API] isLocalPreview():\", isLocalPreview());\n\n  try {\n    // Get ICH prediction using enterprise client\n    const fullStrokeResponse = await clientHelpers.predict(\"full_stroke\", payload);\n    console.log(\"[API] Full stroke raw response:\", fullStrokeResponse);\n\n    // Extract ICH data from nested structure\n    const ichResult = fullStrokeResponse.ich_prediction || {};\n    console.log(\"[API] Extracted ICH data:\", ichResult);\n\n    // Get LVO prediction using enhanced LVO function\n    let lvoResult = fullStrokeResponse.lvo_prediction || {};\n    // try {\n    //   console.log(\"üîÑ Using dedicated LVO prediction (cloud function + fallback)\");\n    //   lvoResult = await predictLVO(payload);\n    //   console.log(\"‚úÖ LVO prediction successful via dedicated function\");\n    // } catch (lvoError) {\n    //   console.warn(\"‚ö†Ô∏è Dedicated LVO prediction failed:\", lvoError);\n\n    //   // Fallback: try to extract LVO from full stroke response if available\n    //   if (ichResult.lvo_prediction) {\n    //     lvoResult = {\n    //       probability: ichResult.lvo_prediction.probability || 0,\n    //       drivers: ichResult.lvo_prediction.drivers || null,\n    //       confidence: ichResult.lvo_prediction.confidence || 0.8,\n    //       module: \"Full Stroke (API Fallback)\",\n    //     };\n    //   } else {\n    //     // Final fallback to local LVO model\n    //     lvoResult = await predictLVO(payload);\n    //   }\n    // }\n\n    return {\n      ich: {\n        probability: ichResult.probability,\n        drivers: ichResult.drivers\n          ? formatDriversFromDict(ichResult.drivers, \"ICH\")\n          : ichResult.drivers,\n        confidence: ichResult.confidence,\n        module: ichResult.module,\n      },\n      lvo: {\n        probability: lvoResult.probability,\n        drivers: lvoResult.drivers\n          ? formatDriversFromDict(lvoResult.drivers, \"LVO\")\n          : lvoResult.drivers,\n        confidence: lvoResult.confidence,\n        module: lvoResult.module,\n      },\n    };\n  } catch (error) {\n    console.error(\"Full Stroke prediction failed:\", error);\n\n    if (error.status === 408 && retryCount < 1) {\n      console.log(\"‚è±Ô∏è Retrying Full Stroke API (cold start detected)...\");\n      return predictFullStroke(payload, retryCount + 1);\n    }\n\n    // Use local preview fallback for development\n    if (isLocalPreview()) {\n      const mockData = DEV_CONFIG.mockApiResponses.full_stroke;\n      const ichPrediction = mockData.ich_prediction || {};\n      const lvoPrediction = mockData.lvo_prediction || {};\n\n      return {\n        ich: {\n          probability: clientHelpers.safeParseFloat(ichPrediction.probability, 0),\n          drivers: ichPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(ichPrediction.confidence, 0.85),\n          module: \"Full Stroke (Mock)\",\n        },\n        lvo: {\n          probability: clientHelpers.safeParseFloat(lvoPrediction.probability, 0),\n          drivers: lvoPrediction.drivers || null,\n          confidence: clientHelpers.safeParseFloat(lvoPrediction.confidence, 0.85),\n          module: \"Full Stroke (Mock)\",\n        },\n      };\n    }\n\n    throw new MedicalAPIError(\n      `Failed to get stroke predictions: ${error.message}`,\n      error.status,\n      API_URLS.FULL_STROKE\n    );\n  }\n}\n\n/**\n * Helper function to check if running in local preview\n * @returns {boolean} True if local preview environment\n */\nfunction isLocalPreview() {\n  return [\"localhost\", \"127.0.0.1\", \"0.0.0.0\"].includes(window.location.hostname);\n}\n\n/**\n * Re-export utility functions for backward compatibility\n */\nexport const normalizeBooleans = payload => clientHelpers.normalizeBooleans(payload);\nexport const safeParseFloat = (value, defaultValue) =>\n  clientHelpers.safeParseFloat(value, defaultValue);\n\n/**\n * Get API client statistics for monitoring\n * @returns {Object} Client statistics\n */\nexport function getClientStats() {\n  return clientHelpers.getRequestStats();\n}\n\n/**\n * Cancel all active API requests\n */\nexport function cancelAllRequests() {\n  clientHelpers.cancelAllRequests();\n}\n","/**\n * ICH Volume Calculation and Clinical Assessment\n * Based on validated log-log regression model (R¬≤ = 0.476)\n * Formula: log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)\n *\n * @typedef {import('../types/medical-types.js').ICHVolumeResult} ICHVolumeResult\n * @typedef {import('../types/medical-types.js').ValidationResult} ValidationResult\n */\n\n// Bulletproof error handling utilities\nimport {\n  safeAsync,\n  safeMedicalCalculation,\n  MedicalError,\n  ERROR_CATEGORIES,\n  ERROR_SEVERITY,\n  MEDICAL_ERROR_CODES,\n  validateMedicalInputs,\n} from \"../utils/error-handler.js\";\n\n// Type safety utilities\nimport { TypeChecker, MEDICAL_CONSTANTS } from \"../types/medical-types.js\";\n\n// Professional logging\nimport { medicalLogger, LOG_CATEGORIES } from \"../utils/medical-logger.js\";\n\n// Volume-based risk thresholds with clinical significance\nexport const VOLUME_THRESHOLDS = {\n  low: {\n    max: 10, color: \"#dc2626\", label: \"Small\", severity: \"low\",\n  },\n  moderate: {\n    min: 10, max: 20, color: \"#dc2626\", label: \"Moderate\", severity: \"moderate\",\n  },\n  high: {\n    min: 20, max: 30, color: \"#dc2626\", label: \"Large\", severity: \"high\",\n  },\n  critical: {\n    min: 30, color: \"#dc2626\", label: \"Critical\", severity: \"critical\",\n  },\n};\n\n// 30-day mortality rates by hemorrhage volume (based on clinical literature)\n// Calibrated to Broderick et al. (1993) landmark study:\n// - 30ml = 19% mortality\n// - 60ml = 91% mortality\n// With correlation strengths from observational data\n// Reference thresholds for documentation purposes:\nexport const MORTALITY_BY_VOLUME = {\n  \"<10ml\": \"5-10%\", // Minor hemorrhage\n  \"10-30ml\": \"10-19%\", // Small (Broderick: 30ml=19%)\n  \"30-50ml\": \"19-44%\", // Moderate (interpolated)\n  \"50-60ml\": \"44-91%\", // Large (Broderick: 60ml=91%)\n  \"‚â•60ml\": \"91-100%\", // Massive (Broderick: >60ml=91-100%)\n};\n\n/**\n * Calculate ICH volume from GFAP biomarker value with bulletproof error handling\n * @param {number} gfapValue - GFAP value in pg/ml (29-10,001)\n * @returns {Promise<ICHVolumeResult>} Volume calculation results with type safety\n */\nexport async function calculateICHVolume(gfapValue) {\n  return safeMedicalCalculation(\n    async (inputs) => {\n      const { gfap } = inputs;\n\n      medicalLogger.info(\"ICH volume calculation started\", {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        operation: \"ich_volume_calculation\",\n      });\n\n      // Type safety validation first\n      TypeChecker.ensureType(gfap, \"number\", \"GFAP value\");\n      TypeChecker.ensureRange(gfap, MEDICAL_CONSTANTS.GFAP_RANGE, \"GFAP value\");\n\n      // Validate medical input\n      const validation = validateMedicalInputs(\n        { gfap },\n        {\n          gfap: {\n            required: true,\n            type: \"number\",\n            min: 0,\n            max: 10001,\n            warningMin: 29,\n            warningMax: 10000,\n          },\n        },\n      );\n\n      if (!validation.isValid) {\n        throw new MedicalError(\n          validation.errors[0]?.message || \"Invalid GFAP value\",\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ validationErrors: validation.errors, gfapValue: gfap });\n      }\n\n      // Handle edge cases\n      if (!gfap || gfap <= 0) {\n        return {\n          volume: 0,\n          volumeRange: { min: 0, max: 0 },\n          riskLevel: \"low\",\n          mortalityRate: \"~0%\",\n          isValid: true,\n          calculation: \"No hemorrhage detected\",\n          warnings: [],\n        };\n      }\n\n      // Cap extremely high GFAP values\n      const cappedGfap = Math.min(gfap, 10000);\n      const warnings = [];\n      if (gfap > 10000) {\n        warnings.push(`GFAP value ${gfap} exceeds maximum calculation range and was capped at 10,000 pg/ml`);\n      }\n\n      // Values above 10,000 pg/ml are capped for calculation stability\n      if (cappedGfap !== gfap) {\n        warnings.push(\"GFAP value was adjusted for calculation stability\");\n      }\n\n      // Apply log-log regression formula with error checking\n      if (cappedGfap <= 0) {\n        throw new MedicalError(\n          \"GFAP value must be positive for volume calculation\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ gfapValue: cappedGfap });\n      }\n\n      const logGfap = Math.log10(cappedGfap);\n      if (!isFinite(logGfap)) {\n        throw new MedicalError(\n          \"Invalid logarithm calculation for GFAP value\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ gfapValue: cappedGfap, logValue: logGfap });\n      }\n\n      const logVolume = 0.0192 + 0.4533 * logGfap;\n      if (!isFinite(logVolume)) {\n        throw new MedicalError(\n          \"Invalid volume calculation result\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ logGfap, logVolume });\n      }\n\n      const calculatedVolume = 10 ** logVolume;\n      if (!isFinite(calculatedVolume) || calculatedVolume < 0) {\n        throw new MedicalError(\n          \"Calculated volume is invalid\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ logVolume, calculatedVolume });\n      }\n\n      // Calculate confidence range (¬±30%)\n      const volumeRange = {\n        min: calculatedVolume * 0.7,\n        max: calculatedVolume * 1.3,\n      };\n\n      // Determine risk level based on volume\n      const riskLevel = getVolumeRiskLevel(calculatedVolume);\n\n      // Get mortality rate\n      const mortalityRate = getMortalityRate(calculatedVolume);\n\n      // Format volume for display\n      const displayVolume = calculatedVolume < 1 ? \"<1\" : calculatedVolume.toFixed(1);\n\n      // Safety check for extreme values\n      if (calculatedVolume > 200) {\n        warnings.push(\"Calculated volume is extremely high - please verify GFAP measurement\");\n      }\n\n      /** @type {ICHVolumeResult} */\n      const result = {\n        volume: calculatedVolume,\n        confidence: 0.476, // R¬≤ of the regression model\n        volumeCategory: getVolumeCategory(calculatedVolume),\n        timestamp: new Date().toISOString(),\n        // Legacy properties for backward compatibility\n        displayVolume,\n        volumeRange: {\n          min: volumeRange.min.toFixed(1),\n          max: volumeRange.max.toFixed(1),\n        },\n        riskLevel,\n        mortalityRate,\n        isValid: true,\n        calculation: `Based on GFAP ${gfap} pg/ml`,\n        threshold: calculatedVolume >= 30 ? \"SURGICAL\" : calculatedVolume >= 20 ? \"HIGH_RISK\" : \"MANAGEABLE\",\n        warnings,\n        metadata: {\n          originalGfap: gfap,\n          cappedGfap,\n          calculationTimestamp: new Date().toISOString(),\n        },\n      };\n\n      // Validate final result\n      if (typeof result.volume !== \"number\" || !isFinite(result.volume)) {\n        medicalLogger.error(\"ICH volume calculation result validation failed\", {\n          category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n          gfapValue: gfap,\n          resultVolume: result.volume,\n          resultType: typeof result.volume,\n        });\n        throw new MedicalError(\n          \"Final volume calculation result is invalid\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.CRITICAL,\n        ).withContext({ result });\n      }\n\n      medicalLogger.info(\"ICH volume calculation completed successfully\", {\n        category: LOG_CATEGORIES.MEDICAL_CALCULATION,\n        gfapValue: gfap,\n        calculatedVolume: result.volume,\n        volumeCategory: result.volumeCategory,\n        riskLevel: result.riskLevel,\n        confidence: result.confidence,\n      });\n\n      return result;\n    },\n    { gfap: gfapValue },\n    {\n      timeout: 5000,\n      fallback: (error) => ({\n        volume: 0,\n        volumeRange: { min: 0, max: 0 },\n        riskLevel: \"low\",\n        mortalityRate: \"Calculation unavailable\",\n        isValid: false,\n        calculation: \"Calculation error - using fallback\",\n        error: error.message,\n        fallbackUsed: true,\n        warnings: [\"Volume calculation failed - fallback values used\"],\n      }),\n      context: {\n        operation: \"ich_volume_calculation\",\n        gfapValue,\n        formula: \"log‚ÇÅ‚ÇÄ(Volume) = 0.0192 + 0.4533 √ó log‚ÇÅ‚ÇÄ(GFAP)\",\n      },\n    },\n  );\n}\n\n/**\n * Fast synchronous volume estimate for UI rendering\n * Mirrors the main formula without async/error wrappers.\n * @param {number} gfap\n * @returns {number} estimated volume in ml (>= 0)\n */\nexport function estimateVolumeFromGFAP(gfap) {\n  try {\n    const v = Math.max(0, 10 ** (0.0192 + 0.4533 * Math.log10(Math.max(1, Math.min(gfap, 10000)))));\n    return Number.isFinite(v) ? v : 0;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Estimate mortality band from volume (synchronous, display-only)\n * @param {number} volume\n * @returns {string}\n */\nexport function estimateMortalityFromVolume(volume) {\n  if (!Number.isFinite(volume) || volume <= 0) {\n    return \"5-10%\";\n  }\n  if (volume >= 60) {\n    return \"91-100%\";\n  }\n  if (volume >= 50) {\n    return \"44-91%\";\n  }\n  if (volume >= 30) {\n    return \"19-44%\";\n  }\n  if (volume >= 10) {\n    return \"10-19%\";\n  }\n  return \"5-10%\";\n}\n\n/**\n * Determine risk level based on calculated volume with safety checks\n * @param {number} volume - Calculated volume in ml\n * @returns {string} Risk level key\n */\nfunction getVolumeRiskLevel(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== \"number\" || !isFinite(volume)) {\n      throw new MedicalError(\n        \"Invalid volume for risk level calculation\",\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      throw new MedicalError(\n        \"Volume cannot be negative\",\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume });\n    }\n\n    if (volume >= VOLUME_THRESHOLDS.critical.min) {\n      return \"critical\";\n    }\n    if (volume >= VOLUME_THRESHOLDS.high.min) {\n      return \"high\";\n    }\n    if (volume >= VOLUME_THRESHOLDS.moderate.min) {\n      return \"moderate\";\n    }\n    return \"low\";\n  } catch (error) {\n    // Fallback to 'low' for safety\n    console.warn(\"Risk level calculation failed, defaulting to low:\", error.message);\n    return \"low\";\n  }\n}\n\n/**\n * Get mortality rate based on volume with improved interpolation and safety checks\n * Calibrated to match clinical studies (Broderick 1993: 30ml=19%, 60ml=91%)\n * @param {number} volume - Volume in ml\n * @returns {string} Mortality rate string with citation\n */\nfunction getMortalityRate(volume) {\n  try {\n    // Input validation\n    if (typeof volume !== \"number\" || !isFinite(volume)) {\n      throw new MedicalError(\n        \"Invalid volume for mortality rate calculation\",\n        MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n        ERROR_CATEGORIES.MEDICAL,\n        ERROR_SEVERITY.MEDIUM,\n      ).withContext({ volume, type: typeof volume });\n    }\n\n    if (volume < 0) {\n      return \"Invalid volume\";\n    }\n\n    // For very small hemorrhages\n    if (volume < 10) {\n      return \"5-10%‚Å¥\";\n    }\n\n    // For small hemorrhages (10-30ml)\n    // Broderick: 30ml = 19% mortality\n    if (volume < 30) {\n      // Linear interpolation: 10ml=10%, 30ml=19%\n      const rate = Math.round(10 + (volume - 10) * (19 - 10) / (30 - 10));\n      // Validate interpolated rate\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          \"Calculated mortality rate out of valid range\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%‚Å¥`;\n    }\n\n    // For moderate hemorrhages (30-50ml)\n    // Interpolating from Broderick 30ml=19% to 50ml‚âà44%\n    if (volume < 50) {\n      // Linear interpolation: 30ml=19%, 50ml=44%\n      const rate = Math.round(19 + (volume - 30) * (44 - 19) / (50 - 30));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          \"Calculated mortality rate out of valid range\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬≥`;\n    }\n\n    // For large hemorrhages (50-60ml)\n    // Broderick: 60ml = 91% mortality\n    if (volume < 60) {\n      // Steeper increase: 50ml=44%, 60ml=91%\n      const rate = Math.round(44 + (volume - 50) * (91 - 44) / (60 - 50));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          \"Calculated mortality rate out of valid range\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬≤`;\n    }\n\n    // For massive hemorrhages (‚â•60ml)\n    // Broderick: >60ml = 91-100%\n    if (volume < 80) {\n      // 60ml=91%, 80ml=96%\n      const rate = Math.round(91 + (volume - 60) * (96 - 91) / (80 - 60));\n      if (rate < 0 || rate > 100) {\n        throw new MedicalError(\n          \"Calculated mortality rate out of valid range\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.HIGH,\n        ).withContext({ volume, rate });\n      }\n      return `${rate}%¬π`;\n    }\n\n    // For extreme cases (‚â•80ml)\n    return \"96-100%¬π\";\n  } catch (error) {\n    // Fallback for safety\n    console.warn(\"Mortality rate calculation failed:\", error.message);\n    return \"Rate unavailable\";\n  }\n}\n\n/**\n * Calculate hemorrhage size percentage for visualization with safety checks\n * Based on brain area scaling: 30ml = ~40% of brain area, 100ml = ~70%\n * @param {number} volume - Volume in ml\n * @returns {Promise<number>} Percentage of brain area (0-70)\n */\nexport async function calculateHemorrhageSizePercent(volume) {\n  return safeAsync(\n    async () => {\n      // Input validation\n      if (typeof volume !== \"number\" || !isFinite(volume)) {\n        throw new MedicalError(\n          \"Invalid volume for size percentage calculation\",\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, type: typeof volume });\n      }\n\n      if (volume < 0) {\n        throw new MedicalError(\n          \"Volume cannot be negative for visualization\",\n          MEDICAL_ERROR_CODES.INVALID_VITAL_SIGNS,\n          ERROR_CATEGORIES.VALIDATION,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume });\n      }\n\n      if (volume <= 0) {\n        return 0;\n      }\n      if (volume >= 100) {\n        return 70;\n      } // Maximum 70% of brain area\n\n      // Non-linear scaling for realistic appearance\n      // 30ml = 40%, 100ml = 70%\n      const sqrtValue = Math.sqrt(volume / 30);\n      if (!isFinite(sqrtValue)) {\n        throw new MedicalError(\n          \"Invalid square root calculation for visualization\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, sqrtValue });\n      }\n\n      const basePercent = sqrtValue * 40;\n      const result = Math.min(basePercent, 70);\n\n      // Final validation\n      if (!isFinite(result) || result < 0 || result > 100) {\n        throw new MedicalError(\n          \"Calculated percentage out of valid range\",\n          MEDICAL_ERROR_CODES.CALCULATION_FAILED,\n          ERROR_CATEGORIES.MEDICAL,\n          ERROR_SEVERITY.MEDIUM,\n        ).withContext({ volume, basePercent, result });\n      }\n\n      return result;\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 1000,\n      fallback: () => {\n        // Safe fallback based on simple linear scaling\n        if (volume <= 0) {\n          return 0;\n        }\n        if (volume >= 100) {\n          return 70;\n        }\n        return Math.min((volume / 100) * 70, 70);\n      },\n      context: {\n        operation: \"hemorrhage_size_calculation\",\n        volume,\n      },\n    },\n  );\n}\n\n/**\n * Get color for volume visualization\n * @param {number} volume - Volume in ml\n * @returns {string} CSS color value\n */\nexport function getVolumeColor(volume) {\n  const riskLevel = getVolumeRiskLevel(volume);\n  return VOLUME_THRESHOLDS[riskLevel].color;\n}\n\n/**\n * Test function for validation with comprehensive error handling\n * Tests the calculator with known GFAP values\n */\nexport async function testVolumeCalculator() {\n  return safeAsync(\n    async () => {\n      const testCases = [\n        { gfap: 100, expectedVolume: \"~5ml\" },\n        { gfap: 500, expectedVolume: \"~15ml\" },\n        { gfap: 1000, expectedVolume: \"~21ml\" },\n        { gfap: 1500, expectedVolume: \"~28ml\" },\n        { gfap: 3000, expectedVolume: \"~50ml\" },\n        { gfap: 5000, expectedVolume: \"~72ml\" },\n      ];\n\n      // ICH Volume Calculator Test Results\n      const results = await Promise.allSettled(\n        testCases.map(async (test) => {\n          try {\n            const result = await calculateICHVolume(test.gfap);\n            return {\n              gfap: test.gfap, result, expected: test.expectedVolume, success: true,\n            };\n          } catch (error) {\n            return {\n              gfap: test.gfap,\n              result: null,\n              expected: test.expectedVolume,\n              success: false,\n              error: error.message,\n            };\n          }\n        }),\n      );\n\n      // Process results and handle any failures\n      const processedResults = results.map((result, index) => {\n        if (result.status === \"fulfilled\") {\n          return result.value;\n        }\n        return {\n          gfap: testCases[index].gfap,\n          result: null,\n          expected: testCases[index].expectedVolume,\n          success: false,\n          error: result.reason?.message || \"Test failed\",\n        };\n      });\n\n      const successfulTests = processedResults.filter((r) => r.success).length;\n      const totalTests = testCases.length;\n\n      return {\n        results: processedResults,\n        summary: {\n          total: totalTests,\n          successful: successfulTests,\n          failed: totalTests - successfulTests,\n          successRate: `${Math.round((successfulTests / totalTests) * 100)}%`,\n        },\n        timestamp: new Date().toISOString(),\n      };\n    },\n    {\n      category: ERROR_CATEGORIES.MEDICAL,\n      severity: ERROR_SEVERITY.LOW,\n      timeout: 10000,\n      fallback: (error) => ({\n        results: [],\n        summary: {\n          total: 0,\n          successful: 0,\n          failed: 0,\n          successRate: \"0%\",\n        },\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      }),\n      context: {\n        operation: \"volume_calculator_test\",\n      },\n    },\n  );\n}\n\n/**\n * Get volume category according to medical type definitions\n * @param {number} volume - Volume in ml\n * @returns {'small'|'moderate'|'large'|'massive'} Volume category\n */\nfunction getVolumeCategory(volume) {\n  try {\n    // Type safety validation\n    TypeChecker.ensureType(volume, \"number\", \"volume for categorization\");\n\n    if (volume < 0) {\n      throw new TypeError(\"Volume cannot be negative for categorization\");\n    }\n\n    const thresholds = MEDICAL_CONSTANTS.VOLUME_THRESHOLDS;\n\n    if (volume < thresholds.SMALL) {\n      return \"small\";\n    }\n    if (volume < thresholds.MODERATE) {\n      return \"moderate\";\n    }\n    if (volume < thresholds.LARGE) {\n      return \"large\";\n    }\n    return \"massive\";\n  } catch (error) {\n    // Fallback to 'small' for safety\n    return \"small\";\n  }\n}\n\n/**\n * Format volume for display with appropriate precision\n * @param {number} volume - Volume in ml\n * @returns {string} Formatted volume string\n */\nexport function formatVolumeDisplay(volume) {\n  if (volume < 1) {\n    return \"<1 ml\";\n  }\n  if (volume < 10) {\n    return `${volume.toFixed(1)} ml`;\n  }\n  return `${Math.round(volume)} ml`;\n}\n"],"names":["APIError","message","status","url","MedicalAPIError","formatDriversFromDict","drivers","predictionType","positive","negative","label","weight","a","b","clientHelpers","value","defaultValue","parsed","payload","normalized","key","endpoint","endpointType","controller","timeout","timeoutId","normalizedPayload","response","errorText","result","error","moduleType","API_URLS","warmUpFunctions","warmUpPromises","index","resolve","predictComaIch","apiError","predictLimitedIch","predictFullStroke","retryCount","isLocalPreview","fullStrokeResponse","ichResult","lvoResult","mockData","DEV_CONFIG","ichPrediction","lvoPrediction","estimateVolumeFromGFAP","gfap","v","estimateMortalityFromVolume","volume","formatVolumeDisplay"],"mappings":"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"}