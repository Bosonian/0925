// Medical Validation Logic Tests
// Critical for patient safety and data integrity

import { validateForm, validateInput, showValidationErrors, clearValidationErrors } from "../../logic/validate.js";
import { VALIDATION_RULES } from "../../config.js";

describe("Medical Validation Logic", () => {
  describe("GFAP Biomarker Validation", () => {
    test("should accept valid GFAP values within medical range", () => {
      const validValues = [29, 50, 100, 500, 1000, 5000, 10001];

      validValues.forEach((value) => {
        expect(value).toBeValidMedicalValue("gfap");
      });
    });

    test("should reject GFAP values outside medical range", () => {
      const invalidValues = [28, 10002, -1, 0, null, undefined, ""];

      invalidValues.forEach((value) => {
        if (typeof value === "number") {
          expect(value).not.toBeValidMedicalValue("gfap");
        }
      });
    });

    test("should validate GFAP field with proper error messages", () => {
      const fieldName = "gfap_value";
      const fieldValue = "25";
      const rules = VALIDATION_RULES[fieldName];

      const errors = validateInput(fieldName, fieldValue, rules);
      expect(errors.length).toBeGreaterThan(0);
      expect(errors[0]).toContain("29");
    });
  });

  describe("Age Validation", () => {
    test("should accept valid age range for medical assessment", () => {
      const validAges = [18, 25, 45, 65, 85, 100];

      validAges.forEach((age) => {
        expect(age).toBeValidMedicalValue("age");
      });
    });

    test("should reject ages outside medical assessment range", () => {
      const invalidAges = [17, 101, -1, 0];

      invalidAges.forEach((age) => {
        expect(age).not.toBeValidMedicalValue("age");
      });
    });
  });

  describe("Blood Pressure Validation", () => {
    test("should validate systolic blood pressure range", () => {
      const validSystolic = [90, 120, 140, 160, 180, 200];

      validSystolic.forEach((value) => {
        expect(value).toBeValidMedicalValue("bloodPressure");
      });
    });

    test("should validate diastolic blood pressure range", () => {
      const validDiastolic = [60, 80, 90, 100, 110, 120];

      validDiastolic.forEach((value) => {
        expect(value).toBeValidMedicalValue("bloodPressure");
      });
    });

    test("should ensure systolic > diastolic through validation", () => {
      const errors = validateInput("systolic_bp", "120", VALIDATION_RULES.systolic_bp);
      expect(errors.length).toBe(0);
    });

    test("should validate medical reasonableness of blood pressure", () => {
      // Test extremely low values
      const lowSystolic = validateInput("systolic_bp", "40", VALIDATION_RULES.systolic_bp);
      const lowDiastolic = validateInput("diastolic_bp", "20", VALIDATION_RULES.diastolic_bp);

      expect(lowSystolic.length).toBeGreaterThan(0);
      expect(lowDiastolic.length).toBeGreaterThan(0);
    });
  });

  describe("Critical Medical Field Validation", () => {
    test("should validate Glasgow Coma Scale range", () => {
      const fieldName = "gcs";
      const fieldValue = "8";
      const rules = { required: true, min: 3, max: 15, type: "number" };

      const errors = validateInput(fieldName, fieldValue, rules);
      expect(errors.length).toBe(0);
    });

    test("should reject invalid GCS values", () => {
      const invalidGCS = ["2", "16", "-1"];
      const rules = { required: true, min: 3, max: 15, type: "number" };

      invalidGCS.forEach((value) => {
        const errors = validateInput("gcs", value, rules);
        expect(errors.length).toBeGreaterThan(0);
      });
    });
  });

  describe("Form Validation Integration", () => {
    test("should validate complete coma module form", () => {
      const mockComaForm = {
        elements: {
          gfap: {
            value: "150.5",
            type: "number",
            name: "gfap",
            required: true,
          },
        },
      };

      const result = validateForm(mockComaForm);
      expect(result.isValid).toBe(true);
      expect(Object.keys(result.validationErrors)).toHaveLength(0);
    });

    test("should validate complete limited module form", () => {
      const mockLimitedForm = {
        elements: {
          age: {
            value: "65", type: "number", name: "age", required: true,
          },
          systolic_bp: {
            value: "160", type: "number", name: "systolic_bp", required: true,
          },
          diastolic_bp: {
            value: "95", type: "number", name: "diastolic_bp", required: true,
          },
          gfap: {
            value: "250.0", type: "number", name: "gfap", required: true,
          },
          weakness_sudden: {
            value: "true", type: "checkbox", name: "weakness_sudden", checked: true,
          },
          speech_sudden: {
            value: "false", type: "checkbox", name: "speech_sudden", checked: false,
          },
        },
      };

      const result = validateForm(mockLimitedForm);
      expect(result.isValid).toBe(true);
    });

    test("should identify all validation errors in invalid form", () => {
      const mockInvalidForm = {
        elements: {
          age_years: {
            value: "15", type: "number", name: "age_years", required: true,
          },
          gfap_value: {
            value: "25", type: "number", name: "gfap_value", required: true,
          },
          systolic_bp: {
            value: "80", type: "number", name: "systolic_bp", required: true,
          },
          diastolic_bp: {
            value: "120", type: "number", name: "diastolic_bp", required: true,
          },
        },
      };

      const result = validateForm(mockInvalidForm);
      expect(result.isValid).toBe(false);
      expect(Object.keys(result.validationErrors).length).toBeGreaterThan(0);
      expect(result.validationErrors.age_years).toBeDefined();
      expect(result.validationErrors.gfap_value).toBeDefined();
    });
  });

  describe("Error Display Functions", () => {
    test("should safely display validation errors without XSS", () => {
      const mockInputGroup = {
        classList: {
          add: jest.fn(),
        },
        querySelectorAll: jest.fn().mockReturnValue([]),
        appendChild: jest.fn(),
      };

      const mockInput = {
        closest: jest.fn().mockReturnValue(mockInputGroup),
      };

      const mockContainer = {
        querySelector: jest.fn().mockReturnValue(mockInput),
        querySelectorAll: jest.fn().mockReturnValue([]),
      };

      const errors = {
        gfap_value: ["Invalid GFAP value<script>alert(\"xss\")</script>"],
      };

      // Should not throw and should sanitize malicious content
      expect(() => {
        showValidationErrors(mockContainer, errors);
      }).not.toThrow();

      expect(mockContainer.querySelector).toHaveBeenCalledWith("[name=\"gfap_value\"]");
      expect(mockInput.closest).toHaveBeenCalledWith(".input-group");
      expect(mockInputGroup.classList.add).toHaveBeenCalledWith("error");
    });
  });

  describe("Medical Safety Edge Cases", () => {
    test("should handle null and undefined values safely", () => {
      const gfapRules = VALIDATION_RULES.gfap_value;
      const ageRules = VALIDATION_RULES.age_years;

      expect(() => validateInput("gfap_value", null, gfapRules)).not.toThrow();
      expect(() => validateInput("age_years", undefined, ageRules)).not.toThrow();
    });

    test("should handle extreme boundary values correctly", () => {
      const boundaryTests = [
        { name: "gfap_value", value: "29", expected: true },
        { name: "gfap_value", value: "10001", expected: true },
        { name: "gfap_value", value: "28.99", expected: false },
        { name: "gfap_value", value: "10001.01", expected: false },
      ];

      boundaryTests.forEach((test) => {
        const rules = VALIDATION_RULES[test.name];
        const errors = validateInput(test.name, test.value, rules);
        const isValid = errors.length === 0;

        // Note: Values that trigger medical warnings (like 10001) will have warnings but still be valid
        // Only min/max violations should make them invalid
        if (test.name === "gfap_value" && parseFloat(test.value) === 10001) {
          // 10001 triggers medical warning but is still within valid range
          expect(errors.length).toBeGreaterThan(0); // Has medical warning
          expect(errors.some(error => error.includes("Extremely high GFAP"))).toBe(true);
        } else {
          expect(isValid).toBe(test.expected);
        }
      });
    });
  });

  describe("Medical Check Functions", () => {
    test("should validate GFAP medical checks for extremely high values", () => {
      const rules = VALIDATION_RULES.gfap_value;
      const errors = validateInput("gfap_value", "6000", rules);

      expect(errors.length).toBeGreaterThan(0);
      expect(errors.some(error => error.includes("Extremely high GFAP"))).toBe(true);
    });

    test("should validate blood pressure medical cross-checks", () => {
      const formData = { systolic_bp: "120", diastolic_bp: "140" };
      const systolicRules = VALIDATION_RULES.systolic_bp;
      const diastolicRules = VALIDATION_RULES.diastolic_bp;

      const systolicErrors = validateInput("systolic_bp", "120", systolicRules, formData);
      const diastolicErrors = validateInput("diastolic_bp", "140", diastolicRules, formData);

      expect(systolicErrors.some(error => error.includes("higher than diastolic"))).toBe(true);
      expect(diastolicErrors.some(error => error.includes("lower than systolic"))).toBe(true);
    });

    test("should validate GCS medical warnings", () => {
      const rules = VALIDATION_RULES.gcs;
      const errors = validateInput("gcs", "6", rules);

      expect(errors.some(error => error.includes("severe consciousness impairment"))).toBe(true);
    });

    test("should validate FAST-ED score medical warnings", () => {
      const rules = VALIDATION_RULES.fast_ed_score;
      const errors = validateInput("fast_ed_score", "5", rules);

      expect(errors.some(error => error.includes("High FAST-ED score"))).toBe(true);
    });

    test("should validate age medical advisory", () => {
      const rules = VALIDATION_RULES.age_years;
      const errors = validateInput("age_years", "16", rules);

      expect(errors.some(error => error.includes("typically for adults"))).toBe(true);
    });
  });

  describe("Clear Validation Errors Function", () => {
    test("should clear validation errors from DOM elements", () => {
      const mockErrorMessage = {
        remove: jest.fn(),
      };

      const mockGroup = {
        classList: {
          remove: jest.fn(),
        },
        querySelectorAll: jest.fn().mockReturnValue([mockErrorMessage]),
      };

      const mockContainer = {
        querySelectorAll: jest.fn().mockReturnValue([mockGroup]),
      };

      clearValidationErrors(mockContainer);

      expect(mockContainer.querySelectorAll).toHaveBeenCalledWith(".input-group.error");
      expect(mockGroup.classList.remove).toHaveBeenCalledWith("error");
      expect(mockGroup.querySelectorAll).toHaveBeenCalledWith(".error-message");
      expect(mockErrorMessage.remove).toHaveBeenCalled();
    });
  });

  describe("Pattern Validation", () => {
    test("should validate pattern rules when provided", () => {
      const rules = {
        pattern: /^[0-9]+$/,
        required: true,
      };

      const validValue = "123";
      const invalidValue = "abc";

      const validErrors = validateInput("test", validValue, rules);
      const invalidErrors = validateInput("test", invalidValue, rules);

      expect(validErrors.length).toBe(0);
      expect(invalidErrors.length).toBeGreaterThan(0);
      expect(invalidErrors.some(error => error.includes("Invalid format"))).toBe(true);
    });
  });

  describe("Edge Cases and Type Safety", () => {
    test("should handle empty string values correctly", () => {
      const rules = { required: false, min: 10, max: 100 };
      const errors = validateInput("test", "", rules);

      expect(errors.length).toBe(0); // Empty string should not trigger min/max validation
    });

    test("should handle zero values correctly for required fields", () => {
      const rules = { required: true, min: 0, max: 100 };
      const errors = validateInput("test", 0, rules);

      expect(errors.length).toBe(0); // Zero should be valid for required fields
    });

    test("should handle non-numeric values for min/max validation", () => {
      const rules = { min: 10, max: 100 };
      const errors = validateInput("test", "not-a-number", rules);

      expect(errors.length).toBe(0); // Non-numeric values should not trigger min/max validation
    });

    test("should handle missing form data in medical checks", () => {
      const rules = VALIDATION_RULES.systolic_bp;
      const errors = validateInput("systolic_bp", "120", rules, null);

      expect(errors.length).toBe(0); // Should not crash with null form data
    });

    test("should handle medical check functions that return null", () => {
      const rules = {
        medicalCheck: () => null,
      };
      const errors = validateInput("test", "50", rules);

      expect(errors.length).toBe(0); // Null medical check should not add errors
    });
  });

  describe("Integration with Form Validation", () => {
    test("should validate complete form with medical checks", () => {
      const mockForm = {
        elements: {
          gfap_value: { value: "6000" }, // Should trigger medical warning
          age_years: { value: "16" }, // Should trigger medical advisory
          systolic_bp: { value: "120" },
          diastolic_bp: { value: "140" }, // Should trigger BP cross-check error
        },
      };

      const result = validateForm(mockForm);

      expect(result.isValid).toBe(false);
      expect(result.validationErrors.gfap_value).toBeDefined();
      expect(result.validationErrors.age_years).toBeDefined();
      expect(result.validationErrors.diastolic_bp).toBeDefined();
    });

    test("should handle forms with missing elements gracefully", () => {
      const mockForm = {
        elements: {
          gfap_value: { value: "150" },
          // Missing other required fields
        },
      };

      const result = validateForm(mockForm);

      // Should not crash and should validate only present fields
      expect(result.isValid).toBe(true);
      expect(Object.keys(result.validationErrors)).toHaveLength(0);
    });
  });
});
