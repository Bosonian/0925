/**
 * Clinical Reporting System Test Suite
 * Medical-Grade Report Generation and Compliance Testing
 */

import {
  ClinicalReportGenerator,
  ClinicalReport,
  ReportType,
  ReportFormat,
  DeliveryMethod,
  QualityMetrics,
  OutcomePredictor,
  ReportValidationError,
} from "../../analytics/clinical-reporting.js";

// Mock dependencies
jest.mock("jspdf", () => ({
  jsPDF: jest.fn().mockImplementation(() => ({
    text: jest.fn(),
    addPage: jest.fn(),
    save: jest.fn(),
    output: jest.fn().mockReturnValue("mock-pdf-data"),
  })),
}));

jest.mock("html2canvas", () => jest.fn().mockResolvedValue({
  toDataURL: jest.fn().mockReturnValue("data:image/png;base64,mock-canvas-data"),
}));

describe("ClinicalReportGenerator", () => {
  let reportGenerator;
  let mockAuditTrail;
  let mockPatientData;

  beforeEach(() => {
    mockAuditTrail = {
      logReportGeneration: jest.fn(),
      logReportDelivery: jest.fn(),
      logDataAccess: jest.fn(),
    };

    mockPatientData = {
      patientId: "PT12345",
      demographics: {
        age: 65,
        gender: "M",
        medicalRecordNumber: "MRN789",
      },
      strokeAssessment: {
        timestamp: new Date("2025-01-15T10:30:00Z"),
        nihssScore: 8,
        gfapLevel: 150.5,
        riskScore: 0.75,
        recommendation: "thrombolysis",
      },
      clinicalData: {
        vitalSigns: {
          bloodPressure: "160/90",
          heartRate: 85,
          oxygenSaturation: 98,
        },
        symptoms: ["aphasia", "hemiparesis", "facial_droop"],
        onsetTime: new Date("2025-01-15T08:00:00Z"),
      },
    };

    reportGenerator = new ClinicalReportGenerator({
      auditTrail: mockAuditTrail,
      templates: {
        header: "Clinical Report Template",
        footer: "Generated by iGFAP Stroke Triage Assistant",
      },
      branding: {
        logo: "data:image/png;base64,mock-logo",
        institution: "Medical Center",
        department: "Emergency Department",
      },
    });
  });

  describe("Initialization", () => {
    test("should initialize with default configuration", () => {
      const defaultGenerator = new ClinicalReportGenerator();

      expect(defaultGenerator.config.outputDirectory).toBe("./reports");
      expect(defaultGenerator.config.retentionDays).toBe(2555); // 7 years
      expect(defaultGenerator.qualityMetrics).toBeDefined();
    });

    test("should initialize with custom configuration", () => {
      expect(reportGenerator.config.templates.header).toBe("Clinical Report Template");
      expect(reportGenerator.config.branding.institution).toBe("Medical Center");
      expect(reportGenerator.auditTrail).toBe(mockAuditTrail);
    });
  });

  describe("Report Type Generation", () => {
    test("should generate clinical summary report", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          includeCharts: true,
          includeMedicalHistory: true,
        },
      );

      expect(report).toBeInstanceOf(ClinicalReport);
      expect(report.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(report.format).toBe(ReportFormat.HTML);
      expect(report.content).toContain("Clinical Summary");
      expect(report.content).toContain(mockPatientData.patientId);
      expect(report.metadata.patientId).toBe("PT12345");
    });

    test("should generate outcome prediction report", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.OUTCOME_PREDICTION,
        mockPatientData,
        {
          format: ReportFormat.PDF,
          predictionModels: ["stroke_severity", "functional_outcome"],
          confidenceInterval: 0.95,
        },
      );

      expect(report.type).toBe(ReportType.OUTCOME_PREDICTION);
      expect(report.format).toBe(ReportFormat.PDF);
      expect(report.content).toContain("Outcome Prediction");
      expect(report.predictions).toBeDefined();
      expect(report.predictions.length).toBeGreaterThan(0);
    });

    test("should generate risk assessment report", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.RISK_ASSESSMENT,
        mockPatientData,
        {
          format: ReportFormat.JSON,
          riskFactors: ["age", "nihss", "gfap_level"],
          includeRecommendations: true,
        },
      );

      expect(report.type).toBe(ReportType.RISK_ASSESSMENT);
      expect(report.riskAnalysis).toBeDefined();
      expect(report.riskAnalysis.totalRisk).toBe(0.75);
      expect(report.recommendations).toBeDefined();
    });

    test("should generate decision support report", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.DECISION_SUPPORT,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          includeClinicalGuidelines: true,
          includeEvidenceBase: true,
        },
      );

      expect(report.type).toBe(ReportType.DECISION_SUPPORT);
      expect(report.clinicalGuidelines).toBeDefined();
      expect(report.evidenceBase).toBeDefined();
      expect(report.recommendations).toContain("thrombolysis");
    });

    test("should generate quality metrics report", async () => {
      const qualityData = {
        doorToNeedleTime: 45, // minutes
        accuracyMetrics: { sensitivity: 0.92, specificity: 0.88 },
        patientOutcomes: { goodOutcome: 0.78 },
        adherenceToProtocols: 0.95,
      };

      const report = await reportGenerator.generateReport(
        ReportType.QUALITY_METRICS,
        qualityData,
        {
          format: ReportFormat.CSV,
          period: { start: "2025-01-01", end: "2025-01-31" },
          includeComparisons: true,
        },
      );

      expect(report.type).toBe(ReportType.QUALITY_METRICS);
      expect(report.metrics).toBeDefined();
      expect(report.metrics.doorToNeedleTime).toBe(45);
    });

    test("should generate comprehensive report", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.COMPREHENSIVE,
        mockPatientData,
        {
          format: ReportFormat.PDF,
          sections: ["summary", "assessment", "predictions", "quality"],
          includeAppendices: true,
        },
      );

      expect(report.type).toBe(ReportType.COMPREHENSIVE);
      expect(report.sections).toContain("summary");
      expect(report.sections).toContain("assessment");
      expect(report.sections).toContain("predictions");
      expect(report.content.length).toBeGreaterThan(1000); // Comprehensive content
    });
  });

  describe("Report Formatting", () => {
    test("should format report as HTML", async () => {
      const htmlReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.CLINICAL_SUMMARY,
        ReportFormat.HTML,
      );

      expect(htmlReport.content).toContain("<html>");
      expect(htmlReport.content).toContain("<head>");
      expect(htmlReport.content).toContain("<body>");
      expect(htmlReport.content).toContain("Clinical Summary");
      expect(htmlReport.mimeType).toBe("text/html");
    });

    test("should format report as PDF", async () => {
      const pdfReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.CLINICAL_SUMMARY,
        ReportFormat.PDF,
      );

      expect(pdfReport.content).toBe("mock-pdf-data");
      expect(pdfReport.mimeType).toBe("application/pdf");
      expect(pdfReport.fileName).toMatch(/\.pdf$/);
    });

    test("should format report as JSON", async () => {
      const jsonReport = await reportGenerator.formatReport(
        mockPatientData,
        ReportType.RISK_ASSESSMENT,
        ReportFormat.JSON,
      );

      const parsedContent = JSON.parse(jsonReport.content);
      expect(parsedContent).toHaveProperty("patientId");
      expect(parsedContent).toHaveProperty("riskScore");
      expect(jsonReport.mimeType).toBe("application/json");
    });

    test("should format report as CSV", async () => {
      const qualityData = {
        metrics: [
          { name: "door_to_needle_time", value: 45, unit: "minutes" },
          { name: "accuracy", value: 0.92, unit: "percentage" },
        ],
      };

      const csvReport = await reportGenerator.formatReport(
        qualityData,
        ReportType.QUALITY_METRICS,
        ReportFormat.CSV,
      );

      expect(csvReport.content).toContain("name,value,unit");
      expect(csvReport.content).toContain("door_to_needle_time,45,minutes");
      expect(csvReport.mimeType).toBe("text/csv");
    });
  });

  describe("Report Customization", () => {
    test("should apply custom templates", async () => {
      const customTemplate = {
        header: "Custom Hospital Header",
        patientSection: "<div class=\"patient-info\">{{patientData}}</div>",
        footer: "Custom Footer with Disclaimer",
      };

      reportGenerator.addTemplate("custom_summary", customTemplate);

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          template: "custom_summary",
          format: ReportFormat.HTML,
        },
      );

      expect(report.content).toContain("Custom Hospital Header");
      expect(report.content).toContain("Custom Footer with Disclaimer");
    });

    test("should include custom branding", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        { format: ReportFormat.HTML },
      );

      expect(report.content).toContain("Medical Center");
      expect(report.content).toContain("Emergency Department");
      expect(report.content).toContain("mock-logo");
    });

    test("should support custom styling", async () => {
      const customStyles = {
        primaryColor: "#2c5aa0",
        secondaryColor: "#f8f9fa",
        fontFamily: "Arial, sans-serif",
        logoPosition: "top-right",
      };

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
        {
          format: ReportFormat.HTML,
          customStyles,
        },
      );

      expect(report.content).toContain("#2c5aa0");
      expect(report.content).toContain("Arial, sans-serif");
    });
  });

  describe("Data Validation and Security", () => {
    test("should validate required patient data", async () => {
      const incompleteData = {
        patientId: "PT12345",
        // Missing required fields
      };

      await expect(
        reportGenerator.generateReport(
          ReportType.CLINICAL_SUMMARY,
          incompleteData,
        ),
      ).rejects.toThrow(ReportValidationError);
    });

    test("should sanitize sensitive data in reports", async () => {
      const sensitiveData = {
        ...mockPatientData,
        demographics: {
          ...mockPatientData.demographics,
          ssn: "123-45-6789",
          insuranceNumber: "INS987654",
        },
      };

      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        sensitiveData,
        {
          format: ReportFormat.HTML,
          sanitizePII: true,
        },
      );

      expect(report.content).not.toContain("123-45-6789");
      expect(report.content).not.toContain("INS987654");
      expect(report.content).toContain("[REDACTED]");
    });

    test("should validate report permissions", async () => {
      const restrictedUser = {
        userId: "nurse123",
        role: "nurse",
        permissions: ["view_basic_reports"],
      };

      await expect(
        reportGenerator.generateReport(
          ReportType.COMPREHENSIVE,
          mockPatientData,
          {
            requestedBy: restrictedUser,
            validatePermissions: true,
          },
        ),
      ).rejects.toThrow("Insufficient permissions");
    });

    test("should log report generation events", async () => {
      await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
      );

      expect(mockAuditTrail.logReportGeneration).toHaveBeenCalledWith(
        expect.objectContaining({
          reportType: ReportType.CLINICAL_SUMMARY,
          patientId: "PT12345",
        }),
      );
    });
  });

  describe("Quality Metrics Integration", () => {
    test("should calculate door-to-needle time metrics", () => {
      const timestamps = {
        arrivalTime: new Date("2025-01-15T08:00:00Z"),
        tpaAdministration: new Date("2025-01-15T08:42:00Z"),
      };

      const metrics = reportGenerator.calculateDoorToNeedleTime(timestamps);
      expect(metrics.doorToNeedleMinutes).toBe(42);
      expect(metrics.meetsBenchmark).toBe(true); // < 60 minutes
    });

    test("should calculate model accuracy metrics", () => {
      const predictions = [
        { predicted: 0.8, actual: 1, threshold: 0.5 },
        { predicted: 0.3, actual: 0, threshold: 0.5 },
        { predicted: 0.7, actual: 1, threshold: 0.5 },
        { predicted: 0.2, actual: 0, threshold: 0.5 },
      ];

      const metrics = reportGenerator.calculateAccuracyMetrics(predictions);
      expect(metrics.accuracy).toBe(1.0);
      expect(metrics.sensitivity).toBe(1.0);
      expect(metrics.specificity).toBe(1.0);
    });

    test("should generate quality improvement recommendations", () => {
      const qualityData = {
        doorToNeedleTime: 75, // Exceeds benchmark
        accuracy: 0.85,
        protocolAdherence: 0.88,
      };

      const recommendations = reportGenerator.generateQualityRecommendations(qualityData);

      expect(recommendations).toContain("door-to-needle time");
      expect(recommendations.length).toBeGreaterThan(0);
    });
  });

  describe("Automated Report Delivery", () => {
    test("should configure email delivery", () => {
      const emailConfig = {
        method: DeliveryMethod.EMAIL,
        recipients: ["physician@hospital.com", "director@hospital.com"],
        subject: "Clinical Report - Patient PT12345",
        schedule: "immediate",
      };

      reportGenerator.configureDelivery(emailConfig);
      expect(reportGenerator.deliveryConfig.method).toBe(DeliveryMethod.EMAIL);
      expect(reportGenerator.deliveryConfig.recipients.length).toBe(2);
    });

    test("should configure secure file transfer", () => {
      const sftpConfig = {
        method: DeliveryMethod.SECURE_TRANSFER,
        endpoint: "sftp://secure.hospital.com",
        credentials: "encrypted_key",
        directory: "/clinical_reports",
        encryption: "AES-256",
      };

      reportGenerator.configureDelivery(sftpConfig);
      expect(reportGenerator.deliveryConfig.method).toBe(DeliveryMethod.SECURE_TRANSFER);
      expect(reportGenerator.deliveryConfig.encryption).toBe("AES-256");
    });

    test("should deliver report via configured method", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
      );

      const deliveryResult = await reportGenerator.deliverReport(report);

      expect(deliveryResult.success).toBe(true);
      expect(deliveryResult.deliveryId).toBeDefined();
      expect(mockAuditTrail.logReportDelivery).toHaveBeenCalled();
    });

    test("should handle delivery failures gracefully", async () => {
      // Mock delivery failure
      const failingGenerator = new ClinicalReportGenerator({
        deliveryConfig: {
          method: DeliveryMethod.EMAIL,
          recipients: ["invalid@email"],
          failOnError: false,
        },
      });

      const report = await failingGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
      );

      const deliveryResult = await failingGenerator.deliverReport(report);

      expect(deliveryResult.success).toBe(false);
      expect(deliveryResult.error).toBeDefined();
    });
  });

  describe("Scheduled Reporting", () => {
    test("should schedule daily quality reports", () => {
      const schedule = {
        reportType: ReportType.QUALITY_METRICS,
        frequency: "daily",
        time: "06:00",
        recipients: ["quality@hospital.com"],
        parameters: {
          period: "last_24_hours",
          includeComparisons: true,
        },
      };

      const scheduledReport = reportGenerator.scheduleReport(schedule);

      expect(scheduledReport.id).toBeDefined();
      expect(scheduledReport.nextRun).toBeInstanceOf(Date);
      expect(scheduledReport.frequency).toBe("daily");
    });

    test("should schedule weekly comprehensive reports", () => {
      const schedule = {
        reportType: ReportType.COMPREHENSIVE,
        frequency: "weekly",
        dayOfWeek: "monday",
        time: "08:00",
        recipients: ["administration@hospital.com"],
      };

      const scheduledReport = reportGenerator.scheduleReport(schedule);

      expect(scheduledReport.frequency).toBe("weekly");
      expect(scheduledReport.dayOfWeek).toBe("monday");
    });

    test("should execute scheduled reports", async () => {
      const mockScheduledReport = {
        id: "sched123",
        reportType: ReportType.QUALITY_METRICS,
        parameters: { period: "last_7_days" },
        lastRun: null,
      };

      const executionResult = await reportGenerator.executeScheduledReport(mockScheduledReport);

      expect(executionResult.success).toBe(true);
      expect(executionResult.reportId).toBeDefined();
      expect(mockScheduledReport.lastRun).toBeInstanceOf(Date);
    });
  });

  describe("Report Archival and Retention", () => {
    test("should archive completed reports", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
      );

      const archiveResult = await reportGenerator.archiveReport(report);

      expect(archiveResult.archived).toBe(true);
      expect(archiveResult.archiveLocation).toBeDefined();
      expect(archiveResult.retentionUntil).toBeInstanceOf(Date);
    });

    test("should enforce retention policies", async () => {
      const expiredReports = await reportGenerator.getExpiredReports();
      const purgeResult = await reportGenerator.purgeExpiredReports();

      expect(Array.isArray(expiredReports)).toBe(true);
      expect(purgeResult.purgedCount).toBeGreaterThanOrEqual(0);
    });

    test("should maintain audit trail for archived reports", async () => {
      const report = await reportGenerator.generateReport(
        ReportType.CLINICAL_SUMMARY,
        mockPatientData,
      );

      await reportGenerator.archiveReport(report);

      expect(mockAuditTrail.logDataAccess).toHaveBeenCalledWith(
        expect.objectContaining({
          action: "archive",
          resourceType: "clinical_report",
        }),
      );
    });
  });
});

describe("ClinicalReport", () => {
  let sampleReport;

  beforeEach(() => {
    sampleReport = new ClinicalReport({
      id: "RPT12345",
      type: ReportType.CLINICAL_SUMMARY,
      format: ReportFormat.HTML,
      patientId: "PT12345",
      generatedBy: "physician123",
      content: "<html><body>Sample Report</body></html>",
      metadata: {
        version: "1.0",
        timestamp: new Date(),
        dataSource: "stroke_triage_system",
      },
    });
  });

  describe("Report Properties", () => {
    test("should have required properties", () => {
      expect(sampleReport.id).toBe("RPT12345");
      expect(sampleReport.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(sampleReport.format).toBe(ReportFormat.HTML);
      expect(sampleReport.patientId).toBe("PT12345");
      expect(sampleReport.content).toContain("Sample Report");
    });

    test("should generate unique report IDs", () => {
      const report1 = new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY });
      const report2 = new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY });

      expect(report1.id).not.toBe(report2.id);
    });

    test("should track generation timestamp", () => {
      expect(sampleReport.generatedAt).toBeInstanceOf(Date);
      expect(sampleReport.generatedAt.getTime()).toBeLessThanOrEqual(Date.now());
    });
  });

  describe("Report Validation", () => {
    test("should validate required fields", () => {
      expect(() => new ClinicalReport({})).toThrow("Report type is required");
      expect(() => new ClinicalReport({ type: ReportType.CLINICAL_SUMMARY }))
        .not.toThrow();
    });

    test("should validate content format", () => {
      const invalidReport = new ClinicalReport({
        type: ReportType.CLINICAL_SUMMARY,
        format: ReportFormat.JSON,
        content: "invalid json content",
      });

      expect(() => invalidReport.validateContent()).toThrow("Invalid JSON content");
    });
  });

  describe("Report Serialization", () => {
    test("should serialize to JSON", () => {
      const json = sampleReport.toJSON();

      expect(json.id).toBe("RPT12345");
      expect(json.type).toBe(ReportType.CLINICAL_SUMMARY);
      expect(json.generatedAt).toBe(sampleReport.generatedAt.toISOString());
    });

    test("should create report from JSON", () => {
      const json = sampleReport.toJSON();
      const restoredReport = ClinicalReport.fromJSON(json);

      expect(restoredReport.id).toBe(sampleReport.id);
      expect(restoredReport.type).toBe(sampleReport.type);
      expect(restoredReport.content).toBe(sampleReport.content);
    });
  });
});

describe("OutcomePredictor", () => {
  let predictor;

  beforeEach(() => {
    predictor = new OutcomePredictor({
      models: ["functional_outcome", "mortality_risk", "length_of_stay"],
      confidenceThreshold: 0.8,
    });
  });

  describe("Prediction Models", () => {
    test("should predict functional outcomes", () => {
      const patientData = {
        age: 65,
        nihssScore: 8,
        strokeType: "ischemic",
        treatmentReceived: "thrombolysis",
      };

      const prediction = predictor.predictFunctionalOutcome(patientData);

      expect(prediction).toHaveProperty("mrsScore");
      expect(prediction).toHaveProperty("confidence");
      expect(prediction).toHaveProperty("factors");
    });

    test("should predict mortality risk", () => {
      const patientData = {
        age: 80,
        nihssScore: 15,
        comorbidities: ["atrial_fibrillation", "diabetes"],
      };

      const prediction = predictor.predictMortalityRisk(patientData);

      expect(prediction.risk).toBeGreaterThan(0);
      expect(prediction.risk).toBeLessThanOrEqual(1);
      expect(prediction.riskCategory).toBeDefined();
    });

    test("should predict length of stay", () => {
      const patientData = {
        age: 70,
        nihssScore: 5,
        strokeSeverity: "minor",
      };

      const prediction = predictor.predictLengthOfStay(patientData);

      expect(prediction.days).toBeGreaterThan(0);
      expect(prediction.range).toHaveProperty("min");
      expect(prediction.range).toHaveProperty("max");
    });
  });

  describe("Prediction Validation", () => {
    test("should validate prediction confidence", () => {
      const lowConfidencePrediction = {
        outcome: "good",
        confidence: 0.6,
      };

      const isReliable = predictor.validatePrediction(lowConfidencePrediction);
      expect(isReliable).toBe(false); // Below 0.8 threshold
    });

    test("should provide uncertainty quantification", () => {
      const prediction = predictor.predictFunctionalOutcome({
        age: 65,
        nihssScore: 8,
      });

      expect(prediction.uncertainty).toBeDefined();
      expect(prediction.uncertainty.type).toBeDefined();
      expect(prediction.uncertainty.range).toBeDefined();
    });
  });
});

describe("Report Integration", () => {
  test("should integrate with audit trail system", async () => {
    const mockAuditTrail = {
      logReportGeneration: jest.fn(),
      logDataAccess: jest.fn(),
    };

    const generator = new ClinicalReportGenerator({
      auditTrail: mockAuditTrail,
    });

    await generator.generateReport(
      ReportType.CLINICAL_SUMMARY,
      { patientId: "PT12345" },
    );

    expect(mockAuditTrail.logReportGeneration).toHaveBeenCalled();
  });

  test("should integrate with quality metrics system", async () => {
    const generator = new ClinicalReportGenerator();

    const qualityReport = await generator.generateReport(
      ReportType.QUALITY_METRICS,
      {
        metrics: {
          doorToNeedleTime: 45,
          accuracy: 0.92,
        },
      },
    );

    expect(qualityReport.type).toBe(ReportType.QUALITY_METRICS);
    expect(qualityReport.qualityScore).toBeDefined();
  });
});
